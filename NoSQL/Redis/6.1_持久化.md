# Redis 持久化

将数据从内存中同步到硬盘，这就是持久化。Redis不同于Memcached的很重要一点就是，**Redis支持持久化**

# Redis持久化方式

Redis支持两种方式的持久化叫`快照`和`只追加文件`，可以单独使用其中一种或将二者结合使用。

3. Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， `当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。`
4. 你甚至可以关闭持久化功能，让数据只在服务器运行时存在。

# RDB方式特点以及优缺点介绍

RDB 快照模式(也是默认的方式)，RDB快照是一次又一次地从头开始创造一切,将内存中数据以快照的方式写入到二进制文件中,默认的文件名为dump.rdb.可以通过配置dir和dbfilename两个参数分别指定快照文件的存储路径和文件名。

可以通过配置设置自动做快照持久化的方式。我们可以配置 redis在 n 秒内如果超过 m 个 key 被修改就自动做快照，下面是默认的快照保存配置：

```
save 900 1 #900 秒内如果超过 1 个 key 被修改，则发起快照保存
save 300 10 #300 秒内容如超过 10 个 key 被修改，则发起快照保存
save 60 10000
```

>理清Redis实现快照的过程对我们了解快照文件的特性有很大的帮助。快照的过程如下:

1. Redis使用fork函数创建当前进程的子进程
2. 父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件
3. 当子进程写入完所有数据后会用该临时文件替换旧的RDB文件，至此一次快照操作完成

>在执行fork的时候操作系统（类Unix操作系统）会使用写时复制（copy-on-write）策略，
即fork函数发生的一刻父子进程共享同一内存数据，当父进程要更改其中某片数据时（如执行一个写命令），
`操作系统会将该片数据复制一份以保证子进程的数据不受影响`，所以新的RDB文件存储的是执行fork一刻的内存数据。也就是说
在没有改变某片数据的时候，父子进程是共享同一内存数据的。当要改变某一分片的数据的时候，会把要改变的数据复制一份，然后
父进程做更新数据的操作，子进程使用的是未更改之前的数据(执行fork一刻的数据)。

通过上述过程可以发现Redis在进行快照的过程中不会修改RDB文件，`只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。这使得我们可以通过定时备份RDB文件来实现Redis数据库备份。`RDB文件是经过压缩（可以配置rdbcompression参数以禁用压缩节省CPU占用）的二进制格式，所以占用的空间会小于内存中的数据大小，更加利于传输。

## RDB手动快照

除了自动快照，还可以手动发送SAVE或BGSAVE(即background save)命令让Redis执行快照，两个命令的区别在于，前者是由主进程进行快照操作，会阻塞住其他请求,不推荐使用，后者会通过fork子进程进行快照操作(不会影响主进程处理client请求),而且如果写操作比较多,就会有很多磁盘IO操作,影响性能.

## 从rdb文件恢复数据

Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将一个记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。

## RDB使用场景考量

通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。

## RDB的优点:

1. RDB文件适合用于备份。很适合容灾。
3. RDB最大化了Redis的性能，因为Redis父进程持久化时唯一需要做的是启动(fork)一个子进程，由子进程完成所有剩余工作。父进程实例不需要执行像磁盘IO这样的操作。
4. RDB在重启保存了大数据集的实例时比AOF要快。

## RDB 的缺点

1. 当你需要在Redis停止工作(例如停电)时最小化数据丢失，RDB可能不太好。虽然可以配置不同的保存点(save point)来保存RDB文件(例如，至少5分钟和对数据集100次写之后，但是你可以有多个保存点)。然而，你通常每隔5分钟或更久创建一个RDB快照，所以一旦Redis因为任何原因没有正确关闭而停止工作，你就得做好最近几分钟数据丢失的准备了。
2. RDB需要经常调用fork()子进程来持久化到磁盘。如果数据集很大的话，fork()比较耗时，结果就是，当数据集非常大并且CPU性能不够强大的话，Redis会停止服务客户端几毫秒甚至一秒。AOF也需要fork()，但是你可以调整多久频率重写日志而不会有损(trade-off)持久性(durability)。

# AOF (Append-only file)的优点:

与快照持久化相比，aof 比快照方式有更好的持久化性(durable).因此已成为主流的持久化方案。默认情况下Redis没有开启AOF（append only file）方式的持久化.

由于快照方式是在一定间隔时间做一次的，所以如果 redis 意外 down 掉的话，就会丢失最后一次快照后的所有修改。如果应用要求不能丢失任何修改的话，可以采用 aof 持久化方式。

aof 持久化方式时,redis 会将每一个收到的写命令都会追加到文件中(默认是appendonly.aof)。当 redis 重启时会通过重新执行文件中保存的写命令来在内存中重建整个数据库的内容。

AOF(Append-Only file) 模式: 会记录服务器所有的写请求，在服务重启的时候通过回放执行命令请求来恢复原有的数据,AOF文件记录的是原始的Redis写请求命令

 `AOF持久化记录服务器执行的所有写操作命令`，并`在服务器启动时，通过重新执行这些命令来还原数据集`。AOF文件中的命令全部以 Redis协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小.
 
## aof文件从硬盘缓存写入到硬盘

需要注意的是虽然每次执行更改数据库内容的操作时，AOF都会将命令记录在AOF文件中，但是事实上，由于操作系统的缓存机制，数据并没有真正地写入硬盘，而是进入了系统的硬盘缓存。在默认情况下系统每30秒会执行一次同步操作，以便将硬盘缓存中的内容真正地写入硬盘，在这30秒的过程中如果系统异常退出则会导致硬盘缓存中的数据丢失。一般来讲启用AOF持久化的应用都无法容忍这样的损失，这就需要Redis在写入AOF文件后主动要求系统将缓存内容同步到硬盘中。在Redis中我们可以通过appendfsync参数设置同步的时机：

```shell
# 默认情况下Redis没有开启AOF（append only file-仅附加文件）方式的持久化
appendonly yes //启用 aof 持久化方式

# appendfsync always // 每次请求时fsync,即收到写命令就立即写入磁盘，最安全也是最慢的方式，十分影响Redis的速度,但是保证完全的持久化

appendfsync everysec //每秒fsync(默认的),即每秒钟写入磁盘一次，在性能和持久化方面做了很好的折中,Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。

# appendfsync no //没有fsync,完全依赖 os（即每30秒一次），性能最好,持久化没保证
```

当然由于 os 会在内核中缓存了 write 做的修改，所以可能不是立即写到磁盘上。这样 aof 方式的持久化也还是有可能会丢失部分修改。不过我们可以通过配置文件告诉 redis 我们想要通过 fsync 函数强制 os 写入到磁盘的时机。有三种方式如下（默认是：每秒 fsync 一次）

>默认的每秒fsync策略，写性能也仍然很不错(fsync是由后台线程完成的，主线程继续努力地执行写请求)，即便损失数据，也仅仅损失一秒钟的写数据。

## AOF 的缺点:

1. 对同样的数据集，AOF文件通常要大于等价的RDB文件。AOF文件的体积太大.rdb只保存数据库中真实的没有冗余的数据.
2. AOF可能比RDB慢，这取决于准确的fsync策略。通常fsync设置为每秒一次的话,性能仍然很高，如果关闭fsync，即使在很高的负载下也和RDB一样的快。不过，即使在很大的写负载情况下，RDB还是能提供能好的最大延迟保证。

AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof，可以通过appendfilename参数修改：`appendfilename appendonly.aof`

## 重写/压缩aof

开启AOF持久化后每执行一条命令，Redis就会将该命令写入AOF文件(可能只是写在内核缓冲区,还没有来及写入硬盘,要看fsync策略)。Redis AOF是通过递增地更新一个已经存在的状态,

aof 的方式也同时带来了另一个问题。持久化文件会变的越来越大。例如我们调用 incr test命令 100 次，文件中必须保存全部的 100 条命令，其实有 99 条都是多余的。因为要恢复数据库的状态其实文件中保存一条 set test 100 就够了。为了压缩 aof 的持久化文件。 redis 提供了 bgrewriteaof 命令。收到此命令 redis 将使用与快照类似的方式将内存中的数据以命令的方式保存到临时文件中，最后替换原来的文件。这就是重写.

>AOF文件是纯文本文件，其内容正是Redis客户端向Redis服务器发送的原始通信协议的内容，从中可见Redis确实只记录了前3条命令。然而这时有一个问题是前2条命令其实都是冗余的，因为这两条的执行结果会被第三条命令覆盖。随着执行的命令越来越多，AOF文件的大小也会越来越大，即使内存中实际的数据可能并没有多少。

很自然地，我们希望Redis可以自动优化AOF文件(也就是`重写`)，就上例而言，就是将前两条无用的记录删除，只保留第三条。实际上Redis也正是这样做的，每当达到一定条件时Redis就会自动重写AOF文件，这个条件可以在配置文件中设置：

```shell
# 下面2个命令是配置aof自动执行重写压缩aof文件,相当于手动执行BGREWRITEAOF

# auto-aof-rewrite-percentage参数的意义是当目前的AOF文件大小超过上一次重写时的
# AOF文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时的AOF文件大小为依据。
auto-aof-rewrite-percentage 100

# auto-aof-rewrite-min-size参数限制了允许重写的最小AOF文件大小，
# 通常在AOF文件很小的情况下即使其中有很多冗余的命令我们也并不太关心。一旦超过了这个大小,就允许重写.
auto-aof-rewrite-min-size 64mb

# 那么当AOF文件体积大于64mb，并且AOF的体积比上一次重写之后的体积大了至少一倍（100%）的时候，Redis将执行BGREWRITEAOF命令。
```

当AOF文件变得很大时，Redis会自动在后台进行重写。重写是绝对安全的，因为Redis继续往旧的文件中追加，一旦第二个文件创建完毕，Redis就会切换这两个文件，并开始往新文件追加。

>除了让Redis自动执行重写外，我们还可以主动使用BGREWRITEAOF命令手动执行AOF重写。可见冗余的命令已经被删除了。重写的过程只和内存中的数据有关，和之前的AOF文件无关，这与RDB很相似，只不过二者的文件格式完全不同。

AOF虽然在某个角度可以将数据丢失降低到最小而且对性能影响也很小，但是极端的情况下，体积不断增大的AOF文件很可能会用完硬盘空间。另外，如果AOF体积过大，那么还原操作执行时间就可能会非常长。

为了解决AOF体积过大的问题，用户可以手动向Redis发送 **BGREWRITEAOF命令** ，这个命令会通过移除AOF文件中的冗余命令来重写（rewrite）AOF文件来减小AOF文件的体积。BGREWRITEAOF命令和BGSAVE创建快照原理十分相似，所以AOF文件重写也需要用到子进程，这样会导致性能问题和内存占用问题，和快照持久化一样。更糟糕的是，如果不加以控制的话，AOF文件的体积可能会比快照文件大好几倍。

## 将aof在重启的时候载入内存

在启动时Redis会逐个执行AOF文件中的命令来将硬盘中的数据载入到内存中，载入的速度相较RDB会慢一些。

### RDB 和 AOF ,我应该用哪一个？

一般来说,如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。
Redis允许同时开启AOF和RDB，既保证了数据安全又使得进行备份等操作十分容易。此时重新启动Redis后,Redis会使用AOF文件来恢复数据，因为AOF方式的持久化可能丢失的数据更少。 

如果你非常关心你的数据,但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。

有很多用户单独使用AOF，但是我们并不鼓励这样，因为时常进行RDB快照非常方便于数据库备份，
启动速度也较之快，还避免了AOF引擎的bug。

>注意：基于这些原因，将来我们可能会统一AOF和RDB为一种单一的持久化模型(长远计划)。

# Redis 4.0 对于持久化机制的优化
Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 `aof-use-rdb-preamble` 开启）。

如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分就是压缩格式不再是 AOF 格式，可读性较差。