# 二叉搜索树(BST)

二叉搜索树(Binary Search Tree):二叉搜索树是一种二叉树，有额外以下特点:

1. 节点的左子树只包含键小于节点键的节点。
2. 节点的右子树仅包含键大于节点键的节点。
3. 左右子树每个也必须是二叉搜索树。

---
    Time Complexities(时间复杂度):
    
    Search :  O(h)
    Insertion : O(h)
    Deletion : O(h)
    Extra Space : O(n) for pointers
    
    h: Height of BST(BST的高度)
    n: Number of nodes in BST
    
    If Binary Search Tree is Height Balanced, 
    then h = O(Log n) 
    
    Self-Balancing BSTs such as AVL Tree, Red-Black
    Tree and Splay Tree make sure that height of BST 
    remains O(Log n)
    
    BST provide moderate access/search (quicker than Linked List and slower than arrays).
    BST provide moderate insertion/deletion (quicker than Arrays and slower than Linked Lists).
---

在形式上继承了二叉树，也就是列表List结构的特点，同时也巧妙
借鉴了向量，或者准确的讲是有序向量sorted vector的特点和优势，后者更重要，这种
对sorted vector的借鉴是质的提高.这也是bst相对于其他数据结构更为传神的部分.
实际上 BST中所有这些传神的部分
都集中体现在其中的一个子集
也就是平衡二叉搜索树
balanced binary search tree
简称BBST

二叉搜索树也是由一组数据项
所构成的集合

其中每一个数据项
都拥有各自的关键码key
并以此为特征互相区分

关键码与关键码之间
首先应该能够进行比较
也就是判断孰大孰小
其次 还应支持比对
也就是判断两个关键码
是否完全一致

词条也就是entry
究竟是什么呢？
词条结构应该包括以下要素
首先每一个词条的确应该
拥有一个关键码
而词条所包含的其它信息
则笼统地归入一个名为value的域，每一个词条entry
实际上都是由key和value
构成的这么样一个组合
也称作<key value> pair

可以看到
所谓entry之间的比较和比对
按照这种方式
实际上都转化为了词条中
关键码的比较和比对

我们都将二叉搜索树
Binary Search Tree
简称作BST

BST究竟有什么特点和特征呢？
概括起来只有一条
也就是处处满足顺序性
所谓顺序性具体来说就是
相对于某一个节点V而言
如果它的左后代存在
那么所有的左后代
都不致比它更大
对称地 如果它的右后代存在
那么所有的右后代
都不致比它更小

顺序性必须得到满足
这就意味着左子树中的所有的节点
都不致大于树根
而右子树中的所有的节点
也不致于小于树根

BST的中序遍历序列是单调的(单调递增).(以它们的关键码为序)
只要这个序列是单调变化的那么原二叉树就必然是一棵BST.

二叉搜索树的何种遍历序列是递增的(把二叉树投影到水平方向也是递增的-可以理解为有序向量): 中序

在含n个节点的BST中进行查找的最坏时间复杂度为：O(n)

对BST进行插入操作，对待插入的目标元素e进行查找后，若查找失败，_hot指向的节点为：被插入后的父亲

结点的前驱：是该结点的左子树中的最大结点。
结点的后继：是该结点的右子树中的最小结点。

当欲删除的节点v在BST中的度为2时，实际被删除的节点为：v的右子树中左侧分支的最后一个节点

BST是将之前的List和Vector结构的优势结合起来.从策略上 BST可以视作是
试图将此前的向量结构以及列表结构的优势结合起来.
BST各种接口算法的具体实现,概括而言 无论是静态的search操作
还是动态的insert或remove操作,在最坏的情况下 它们所需要的时间,都线性正比于树的高度
比如作为一种极端情况我们假设在一棵BST中所有的节点度数都不超过1,
也就是说 从整体的拓扑结构而言这棵树实际上已经退化成了一条单链(h = n-1),
从逻辑结构看,已经完全退化地等效为一个列表(链表),不难看出 此时整棵树的高度
与整棵树中节点的个数,成线性正比关系,在这种情况下,无论是就平均还是最坏意义而言
静态操作以及动态操作,都需要高达O(n)的时间.

中位数或者接近于中位数的关键码,越是被更早地插入
整体而言 这棵BST的高度,也相应地会更低,这类高度更低的BST
将会被以更高的重复度参与统计,以及最终的平均估算.
但对于在此非常在意树高的我们来说,这并不是一个好消息
这意味着在天然的随机意义下,这样一个高度是不能够令我们满意的
为了进一步地降低和控制这个高度值,我们应该做点什么

什么样的树相对而言高度是更低的,在节点数目相对固定时
左右兄弟子树的高度越是接近,全树通常也会更加倾向于高度更低
也就是说 全树越是接近于平衡,那么它的高度也会倾向于更低
,因此我们可以通过控制全树的平衡度,以控制全树的高度

关于树的高度 我们有这样一个结论
由n个节点所组成的二叉树
其高度最低不会少于log 2为底n的对数
因此如果某棵树的高度
能够达到这样一个理想的下限
我们也称之为理想平衡的二叉树.

那么哪些树能够达到这样的理想平衡状态呢？
完全二叉树 Complete Binary Tree,是的 在这样的树中
叶节点只能出现在最底层以及次底层,当然 其中最好最好不过的
自然是所谓的满二叉树 Full Binary Tree
然而很遗憾 这样一种完美的形式也是难以持续的

因此所谓的理想平衡在实际应用中是不具任何意义的

是的 理想平衡出现的可能性非常非常的低
而且为了维护这样的理想平衡我们的计算成本也相应地会十分的高昂,相对而言 我们会得不偿失

而真正可行的方法是我们或许应该适度地放松平衡的标准
实际上只要能够保证全树的高度
能够从渐近的意义而言不超过O(logn)-这里是以2为底,那么也就可以称之为是平衡的了
因为这种平衡并非严格意义上的理想平衡,所以我们也不妨称之为适度平衡
那么相应地 能够保持适度平衡的BST
也称作平衡的二叉搜索树Balanced Binary Search Tree简称BBST
也就是说 如果将所有的BST,视作一个全集
那么BBST只是其中的一个子集
对于目前而言其中任何一棵BBST
如果经过某次操作之后,它不再保持适度平衡,也就是说 会游离到这个子集之外
我们就需要有一整套方法将这棵BST重新拉回到这个子集中(使用等价转换的方法),使它重新成为一棵BBST

含n个节点，高度为h的BST称为平衡二叉搜索树,它满足:h=O(log2n)

两个等价的平衡二叉搜索树有相同的: 中序遍历序列 

所谓BST 它的本质特征就是处处局部的顺序性以及全局的单调性
具体来说 只需要考察.它的中序遍历序列是否是单调的

2棵bst,拓扑结构不尽相同,但中序遍历序列却相同的,任何一对这样的BST
也就称作相互等价的BST,等价的BST之间
在拓扑结构上 虽然不尽相同,但也有其独特的规律,概括起来有两句话
第一上下可变,在垂直方向有一定的自由度
第二条规律则是左右不能乱,这里的左右自然是指中序遍历序列
确实相对于任何一个节点,居于它右侧的节点
以及居于它左侧的节点之间不能相互混淆
那么在这样一种上下存在一定的调整余地,但左右次序却不得颠倒的规则下
又当如何来实现BST之间的等价转换呢？

等价变换的过程后，无论是局部
还是在它们所属的那棵全树
顺序性和单调性将依然保持
也就是说变换后全树依然将是一棵BST

从效果来看 这样一个变换
可以大致理解为是在此局部围绕着节点V
做了一个顺时针的旋转
我们称这种变换为zig(http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240184_2X+sp/courseware/06d6c305fca54193901007d83cd6e74e/8f1bcfb9768b441fa267610f164f81e6/)
那么这种旋转的中心V 则是zig的参数
右图是完全对称的另一种基本操作
因为它可以理解为是围绕着节点V
做了一次逆时针的旋转操作
我们也形象地称之为zag。

在后续的章节中 我们将会看到
包括AVL树 红黑树在内的
各种BBST都分别精心地
定义了某种适度平衡的准则
从而使得原本在其中的任何一棵BBST
即便在经过某次操作之后
会暂时地游离到这个边界之外
我们也总是能够通过
一系列精巧地等价变换
令它重新回到这个边界以内
并重新成为一棵BBST
而在设计所有这些等价变换的组合时
我们始终不要忘了
应该遵循两个重要的准则
一个就是所谓的局部性
也就是说 我们执行的每一次等价变换
都应该局限在某一常数规模的局部
比如对于我们刚刚介绍的
zig和zag操作而言
它们都局限在局部的V和C两个节点处
如此它们所牵涉到的节点总数既然是常数
这类操作所需要的计算时间
也可以严格地控制在常数的规模O(1)

第二个需要严格遵守的是
在我们将一棵刚刚失衡的BBST
重新恢复为一棵BST的过程中
累计需要执行的
这样的操作的次数不要过多
比如至多不能超过logn次(O(logn))
这样我们就可以有效地控制
整个操作序列的长度
以及总体所需要的时间
后面我们会看到 任何一种BBST
都必须至少满足这样一个logn的基本条件
但是在进一步的要求上
它们各自又有所差异
比如对于AVL树而言
它的删除操作只能刚刚达到这个及格线
而它的插入操作却可以优化到常数O(1)
而我们在第八章中将要介绍的红黑树
也就是Red Black Tree
则可以进一步地将这两种操作的性能
同时提升到最优的常数O(1)

我们来介绍最为经典的一种平衡二叉搜索树(BBST),也就是AVL树

回顾此前的几节我们首先介绍的是,二叉搜索树BST
然而我们也看到,尽管从同时兼顾高效的静态操作
和动态操作的角度讲,BST相对此前简单的向量和列表
已经具有某种优势和潜质,但是毕竟它并不能保证这一点
其原因在于 它的高度,无论是从平均情况 还是最坏情况
都不能保证做到足够的低,具体来说 也就是做到logn以下

当然 在BST中的确存在这么一种特殊的类型
也就是所谓的Complete Binary Tree-完全二叉树,它的高度可以达到严格的最小
也就是logn,然而 相对于整体的BST,这类BST的数量极少
而且我们如果需要将任何一棵树,转化为一棵完全二叉树,所需要的成本也太高
也正因为此,我们的建议是,或许应该适当地放松所谓平衡的标准
也就是说 我们只需考察某一类在渐近意义下不超过,O(logn)高度的树即可
而这样一类树,也就是我们所说的平衡二叉搜索树Balanced Binary Search Tree


比如我们这一节将要介绍的AVL树就是在这种意义下的一种BBST
以AVL树为代表的这些BBST,首先并没有放弃渐近意义logn的复杂度底线,
同时正因为它已经适度地
放松了平衡的标准,对于任何一棵这样意义下的BBST,在其生命期内
即便在某次操作之后,它不再满足BBST的条件,也就是说游离到BBST这个范畴之外
我们也可以通过上节所介绍的等价变换,迅速地将其重新转化为,一棵等价的BBST
也就是说 可以通过极小的代价,就使之重新归入BBST的范畴,而这种极小的代价是多少呢？
不出你的意料 依然是不超过logn

令刚刚失衡的搜索树重新恢复为一棵BBST的过程
也称作重平衡rebalance而对于包括AVL树在内的
各种BBST而言其核心的技巧 无非两条: 第一 如何来界定一种
适度的平衡标准,其次则是一整套重平衡的技巧和算法

