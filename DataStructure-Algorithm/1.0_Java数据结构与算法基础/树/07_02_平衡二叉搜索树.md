# 平衡二叉搜索树(balanced binary search tree-简称BBST)

二叉搜索树的何种遍历序列是递增的(把二叉树投影到水平方向也是递增的-可以理解为有序向量): 中序

在含n个节点的BST中进行查找的最坏时间复杂度为：O(n)

BST无论是静态的search操作还是动态的insert或remove操作,在最坏的情况下 它们所需要的时间,都线性正比于树的高度

所以我们要想办法降低树的高度.

什么样的树相对而言高度是更低的,在节点数目相对固定时左右兄弟子树的高度越是接近,全树通常也会更加倾向于高度更低
也就是说 全树越是接近于平衡,那么它的高度也会倾向于更低,因此我们可以通过控制全树的平衡度,以控制全树的高度

关于树的高度 我们有这样一个结论
由n个节点所组成的二叉树
其高度最低不会少于log 2为底n的对数

    理想平衡的二叉树

因此如果某棵树的高度能够达到这样一个理想的下限我们也称之为理想平衡的二叉树.

那么哪些树能够达到这样的理想平衡状态呢？

完全二叉树 Complete Binary Tree,在这样的树中叶节点只能出现在最底层以及次底层,当然 其中最好最好不过的就是所谓的满二叉树Full Binary Tree,然而很遗憾 这样一种完美的形式也是难以持续的

因此所谓的理想平衡的二叉树在实际应用中是不具任何意义的,因为理想平衡二叉树出现的可能性非常非常的低,而且为了维护这样的理想平衡我们的计算成本也相应地会十分的高昂,相对而言我们会得不偿失

而真正可行的方法是我们或许应该适度地放松平衡的标准,实际上只要能够保证全树的高度能够从渐近的意义而言不超过O(logn)-这里是以2为底,那么也就可以称之为是平衡的了.

因为这种平衡并非严格意义上的理想平衡,所以我们也不妨称之为适度平衡,那么相应地能够保持适度平衡的BST也称作平衡的二叉搜索树Balanced Binary Search Tree简称BBST

也就是说如果将所有的BST,视作一个全集,那么BBST只是其中的一个子集,对于任何一棵BBST如果经过某次操作之后,它不再保持适度平衡,也就是说 会游离到bbst这个子集之外,我们就需要有一整套方法将这棵游离到bbst子集之外的树重新拉回到bbst子集中使它重新成为一棵BBST.

# 等价变换

两个等价的平衡二叉搜索树有相同的: 中序遍历序列 

所谓BST 它的本质特征就是处处局部的顺序性以及全局的单调性
具体来说 只需要考察.它的中序遍历序列是否是单调的

2棵bst,拓扑结构不尽相同,但中序遍历序列却相同的,任何一对这样的BST
也就称作相互等价的BST,等价的BST之间
在拓扑结构上 虽然不尽相同,但也有其独特的规律,概括起来有两句话

第一上下可变,在垂直方向有一定的自由度
第二条规律则是左右不能乱,这里的左右自然是指中序遍历序列

确实相对于任何一个节点,居于它右侧的节点
以及居于它左侧的节点之间不能相互混淆
那么在这样一种上下存在一定的调整余地,但左右次序却不得颠倒的规则下
又当如何来实现BST之间的等价转换呢？

等价变换的过程后，无论是局部,还是在它们所属的那棵全树,顺序性和单调性将依然保持,也就是说变换后全树依然将是一棵BST

从效果来看 这样一个变换,可以大致理解为是在此局部围绕着节点V,做了一个顺时针的旋转,我们称这种变换为zig,那么这种旋转的中心V 则是zig的参数,右图是完全对称的另一种基本操作,因为它可以理解为是围绕着节点V,做了一次逆时针的旋转操作,我们也形象地称之为zag。

在后续的章节中 我们将会看到,包括AVL树 红黑树在内的,各种BBST都分别精心地,定义了某种适度平衡的准则,从而使得原本在其中的任何一棵BBST,即便在经过某次操作之后,会暂时地游离到这个边界之外,我们也总是能够通过一系列精巧地等价变换令它重新回到这个边界以内,并重新成为一棵BBST,而在设计所有这些等价变换的组合时,我们始终不要忘了,应该遵循两个重要的准则:

一个就是所谓的局部性,也就是说 我们执行的每一次等价变换,都应该局限在某一常数规模的局部,比如对于我们刚刚介绍的
zig和zag操作而言,它们都局限在局部的V和C两个节点处,如此它们所牵涉到的节点总数既然是常数,这类操作所需要的计算时间
也可以严格地控制在常数的规模O(1).

第二个需要严格遵守的是,在我们将一棵刚刚失衡的BBST,重新恢复为一棵BBST的过程中,累计需要执行的
这样的操作的次数不要过多,比如至多不能超过logn次(O(logn)),这样我们就可以有效地控制整个操作序列的长度,以及总体所需要的时间

后面我们会看到 任何一种BBST都必须至少满足这样一个logn的基本条件,但是在进一步的要求上它们各自又有所差异

比如对于AVL树而言它的删除操作只能刚刚达到这个及格线,而它的插入操作却可以优化到常数O(1),而我们在第八章中将要介绍的红黑树
也就是Red Black Tree则可以进一步地将这两种操作的性能同时提升到最优的常数O(1)
