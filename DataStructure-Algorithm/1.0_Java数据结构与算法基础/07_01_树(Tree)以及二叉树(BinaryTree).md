# 为什么会出现树?(树是为了解决什么问题而来的)

- `有序数组`的search效率高(查找的时间复杂度为logN，插入和删除效率低
- `链表`的查找效率低,时间复杂度为O(N),插入和删除效率高,时间复杂度为O(1).

>以上2种结构都是线性结构

树(我们主要研究二叉树)结合了有序数组查找快和链表插入和删除快的优点.`将有序数组和链表的优点融合起来`，Tree不是线性结构，同时他带有
线性结构的特征，所以我们称`树为半线性结构`(从形状上看其实是层次结构)。Tree可以高效地兼顾静态操作(查找)和动态操作(插入和删除)。

>图是非线性结构.

# Tree应该提供的相关的接口:

---

<table>
	<thead>
		<tr>
			<th>节点</th>
			<th>功能</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>root()</td>
			<td>获取根节点</td>
		</tr>
		<tr>
			<td>parent()</td>
			<td>获取某一个节点的父节点</td>
		</tr>
		<tr>
			<td>firstChild()</td>
			<td>获取某一个节点的第一个孩子</td>
		</tr>
		<tr>
			<td>nextSibling()</td>
			<td>获取某一个节点的下一个兄弟节点</td>
		</tr>
		<tr>
			<td>insert(i, e)</td>
			<td>将e作为某一个节点的第i个孩子插入</td>
		</tr>
		<tr>
			<td>remove(i)</td>
			<td>删除某一个节点的第i个孩子</td>
		</tr>
		<tr>
			<td>traverse()</td>
			<td>遍历</td>
		</tr>
	</tbody>
</table>

---

## 树相关的概念以及特点(以二叉树为主)

- 节点的出度(也叫度数degree): 任何一个节点R所拥有的孩子的数目也称作它的度数degree.
- 叶子节点: 没有后代的节点称为叶子(leaf)-叶子节点.
- 节点的深度：任何节点到root节点的长度称作这个节点在这个树中的深度depth.
- 根节点是所有节点的公共祖先，深度为0.
- 树的高度h(height): 所有叶子中深度最大.
- 只有单个节点的树的高度h取0，根本不存在任何节点的树，也就是空树，空树的高度h为-1.
- 一个节点的高度之所以会发生变化,是由于它的左孩子或者右孩子的高度发生了变化而引起的.准确地讲 一个节点的高度应该恰好等于它的左孩子与右孩子高度中的更大者,再加1
- 除根外，任何一个节点有且仅有一个父节点
- 兄弟: 2个节点共同拥有一个父亲，所以他们之前互称兄弟(sibling-兄弟,姐妹).
- 长子兄弟法:每个节点只需要记录2个东西，firstChildren(),nextSibling() ,sibling表示同辈节点的水平引用.

元素与元素之间有某种关系,那么我们就引入一条边连接这两个元素.
不存在关系就不引入这样一条边,我们需要为每一棵树指定一个特殊的顶点我们称之为根root

树的边数和树的顶点的数目是同阶的。
e(edge-边) = n - 1,n为顶点数目.所以在衡量相关复杂度的时候，可以将n作为参考.

v的深度depth(v) = path(v),v为顶点(vertex)的缩写.这个路径中的任何一个
节点称做v的祖先(ancestor),v是它们的后代(descendent),


树的深度(将任何一个节点到root的长度成为这个节点在树中的深度,也就是子树的根节点到全数根节
点的长度称为这棵子树的深度)
和高度(子树中所有叶子，深度最大值成为这个子树的高度)之和不会超过全树的高度.

用父节点+孩子节点(node -> rank data parent children)的方法存储n个节点的树,需要的空间是:O(n)

## 二叉树(Binary Tree)

每个节点最多有2个孩子，他们被称为左孩子和右孩子(每个节点度数(出度)不超过2的tree)。

以左右区分(我们隐含了左在先，右在后的顺序关系):

- lChildren() 
- lSubtree()
- rChildren() 
- rSubtree()

### n(节点总数)和h(树的高度)的关系

* 深度为k的节点，至多2^k个
* 含n个节点，高度为h的二叉树中: h < n < 2^(h+1)
* h < n的原因: 至少在每一层上有一个节点.
* h = n - 1时: 为单链条(每一层一个节点)
* n = 2^(h+1) - 1,为满二叉树，达到饱和状态.满二叉树树的特点是在同样的高度下，顶点数达到最大，也就是饱和状态.

>由此可见一棵树在横向上的宽度和纵向上的高度是成指数关系的，宽度是高度的指数.
指数意味着爆炸.意味着剧烈的增长,高度增长的比较缓慢，宽度增长的非常快，也即是对于
二叉树而言，非常倾向于涨宽,它的涨宽的速度更快.这是我们引入二叉搜索树的重要基础.

### 真二叉树

真二叉树，每个节点的出度是偶数，要么是0，或2.

如果某一个节点，原来的度数是0，那么我们就在它的下方
通过增加两个新的孩子，使之变成两度，如果某一个节点原先的度数是1
我们就在缺失的那一侧，同样地引入一个新的孩子节点，从而同样使得它的度数由1变成2
这样一棵新得到的二叉树中，就不再含有1度的节点，我们称这种二叉树为真二叉树，（叶子节点全都是我们虚拟引入的）

### 长子兄弟法描述多茶树(重点)

描述多叉树: 可以用长子兄弟法描述.

任何一颗一般性的树(即多叉树)均可转化为它的长子兄弟表示法，并且进一步转化为一颗二叉树.所以二叉树可以描述多叉树.

## 二叉树的相关算法

也往往需要对其中的元素按照某种次序来逐一访问, 然而二叉树已经并非严格意义上的线性结构,至少是所谓的半线性结构，或者说是层次结构.二叉树可以用两种方式遍历:

1. Depth First Traversal(深度优先遍历): Inorder (Left-Root-Right), Preorder (Root-Left-Right) and Postorder (Left-Right-Root)
2. Breadth First Traversal(广度优先): Level Order Traversal(层次遍历)

---

    在l层最多节点的数量是 = 2^(l-1).
    
    节点的最多数量为n = 2^h – 1.
    这里h是树的高度，
    
    最小的高度值h =  ceil(Log2(n+1))   
    
    Time Complexity of Tree Traversal(树遍历的时间复杂度): O(n)

---

我们如何才能够将二叉树这种半线性结构,转化为此前我们已经相对而言研究有素的线性结构.具体的来说也就是按照某种事先约定的原则
在二叉树的所有节点之间定义某种明确的线性次序,而具体的转换手法也就是接下来几节要介绍的遍历

实际上这种策略将贯穿我们整个课程,比如 在接下来一章将要介绍的图结构是,属于典型的非线性结构.在那里 我们同样面临一个问题
就是: 如何将非线性结构转化为又相对而言研究有素的半线性结构.在那里 我们的处理手法依然是遍历

如何将半线性结构转化为线性结构?-通过遍历: 即对树中的每一个节点都恰好访问一次

任何一个局部的子树
可以分为树根
它的左子树L和它的右子树R三部分
只要根节点的访问
以及左右子树的遍历次序
能够明确确定
那么在整体上就必然导致一个
明确的线性次序


几种典型的遍历算法也就是所谓的先序、中序以及后序,它们的区别其实就在于
局部的根节点究竟是按什么次序来访问的,如果是先于左右子树 那么就是先序
如果是介于左右子树之间,那么就是中序,如果是位于左右子树的遍历之后,那么也就是后序

## 先序遍历的宏观过程:

整个过程分为两个阶段
首先是自顶而下地依次访问
左侧链上的沿途节点
再倒过来 自底而上地依次遍历
各个层次上的每一棵右子树
这就是我们整个先序遍历的宏观过程

递归算法可以简明实现O(n)的复杂度.

层次遍历中使用到队列,以便是的祖先节点优于后代节点被访问，这不同于
前中后3中遍历，使用了stack。

层次遍历的次序是:自上而下访问各个深度的节点,同样深度的节点中自左向右 

