Vector(向量)的Search效率高，insert和remove效率低

List(这里的List指的是链表)的Search效率低，insert和remove效率高.
以上2种结构都是线性结构。

Tree是将Vector和List的优点融合起来，Tree不是线性结构，同时他带有
线性结构的特征，所以我们称树为半线性结构。可以将Tree看作List<List>,或者
List的2次方.Tree可以高效地兼顾静态操作和动态操作。

图是非线性结构.

Tree应该提供的相关的接口:

<table>
	<thead>
		<tr>
			<th>节点</th>
			<th>功能</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>root()</td>
			<td>获取根节点</td>
		</tr>
		<tr>
			<td>parent()</td>
			<td>获取某一个节点的父节点</td>
		</tr>
		<tr>
			<td>firstChild()</td>
			<td>获取某一个节点的第一个孩子</td>
		</tr>
		<tr>
			<td>nextSibling()</td>
			<td>获取某一个节点的下一个兄弟节点</td>
		</tr>
		<tr>
			<td>insert(i, e)</td>
			<td>将e作为某一个节点的第i个孩子插入</td>
		</tr>
		<tr>
			<td>remove(i)</td>
			<td>删除某一个节点的第i个孩子</td>
		</tr>
		<tr>
			<td>traverse()</td>
			<td>遍历</td>
		</tr>
	</tbody>
</table>

元素与元素之间有某种关系,那么我们就引入一条边连接这两个元素.
不存在关系就不引入这样一条边,我们需要为每一棵树指定一个特殊的顶点我们称之为根root

树的边数和tree的顶点的数目是同阶的。
e(edge-边) = n - 1,n为顶点数目.所以在衡量相关复杂度的时候，可以将n作为参考.

顶点共同拥有一个父亲，所以他们之前互称兄弟sibling.

任何一个节点r所拥有的孩子的数目也称作它的度数degree(官方叫出度)。

若指定Ti作为T的第i棵子树，ri作为r的第i个孩子，则T称作有序树.

Tree无环，所以边数不会太大，而且tree是连通的，所以边也不能太少，在保证连通的情况下，能够保证
边数达到最少.

任何一个节点和根节点之前都存在唯一一条通路，这个就是路径的长度.将任何一个节点到root的长度作为一个指标.
称作这个节点在这个树中的深度depth.v的深度depth(v) = path(v),v为顶点(vertex)的缩写.这个路径中的任何一个
节点称做v的祖先(ancestor),v是它们的后代(descendent),

根节点是所有节点的公共祖先，深度为0.

没有后代的节点称为叶子(leaf)-叶子节点.

所有叶子中深度最大的称为tree(或根节点)的高度:height(v)

树的深度(将任何一个节点到root的长度成为这个节点在树中的深度,也就是子树的根节点到全数根节
点的长度称为这棵子树的深度)
和高度(子树中所有叶子，深度最大值成为这个子树的高度)之和不会超过全树的高度.

除根外，任何一个节点有且仅有一个父节点。

用父节点+孩子节点(node -> rank data parent children)的方法存储n个节点的树,需要的空间是:O(n)

长子兄弟法:每个节点只需要记录2个东西，firstChildren(),nextSibling() ,sibling表示同辈节点的水平引用.

### 二叉树(Binary Tree)

每个节点度数(出度)不超过2的tree，

以左右区分:

lChildren() lSubtree()

rChildren() rSubtree()

我们隐含了左在先，右在后的顺序关系，

深度为k的节点，至多2的k次方个节点

含n个节点，高度为h的二叉树中: h < n < 2的(h+1)次方

h<n: 至少在每一层上有一个节点.

1. n = h + 1时: 为单链条(每一层一个节点)

n = 2的(h+1)次方 - 1,为满二叉树，达到饱和状态.

满树的特点是在同样的高度下，顶点数达到最大，也就是饱和状态.

由此可见一棵树在横向上的宽度和纵向上的高度是成指数关系的，宽度是高度的指数.
指数意味着爆炸.意味着剧烈的增长,高度增长的比较缓慢，宽度增长的非常快，也即是对于
二叉树而言，非常倾向于涨宽,它的涨宽的速度更快.这是我们引入二叉搜索树的重要基础.

真二叉树，每个节点的出度是偶数，要么是0，或2

如果某一个节点，原来的度数是0，那么我们就在它的下方
通过增加两个新的孩子，使之变成两度，如果某一个节点原先的度数是1
我们就在缺失的那一侧，同样地引入一个新的孩子节点，从而同样使得它的度数由1变成2
这样一棵新得到的二叉树中，就不再含有1度的节点，我们称这种二叉树为真二叉树，（叶子节点全都是我们虚拟引入的）


重点:

描述多叉树: 可以用长子兄弟法描述.

任何一颗一般性的树均可转化为它的长子兄弟表示法，并且进一步分转化为理解为一颗二叉树.
所以二叉树可以描述多叉树.

只有单个节点的树的高度取0，
根本不存在任何节点的树，也就是空树，空树的高度为-1.

一个节点的高度
之所以会发生变化
是由于它的左孩子
或者右孩子的高度
发生了变化而引起的
准确地讲 一个节点的高度
应该恰好等于它的左孩子
与右孩子高度中的更大者 再加1


二叉树的相关算法
也往往需要对其中的元素按照某种次序
来逐一访问
然而在前面几节我们已经清晰地看到
二叉树已经并非严格意义上的线性结构
至少是所谓的半线性结构

我们如何才能够将二叉树这种半线性结构
转化为此前我们已经相对而言
研究有素的线性结构
具体的来说也就是
按照某种事先约定的原则
在二叉树的所有节点之间
定义某种明确的线性次序
而具体的转换手法
也就是接下来几节要介绍的遍历

实际上 这种策略将贯穿我们整个课程
比如 在接下来一章
将要介绍的图结构
是属于典型的非线性结构
在那里 我们同样面临一个问题
就是如何将非线性结构转化为
又相对而言研究有素的半线性结构
在那里 我们的处理手法
依然是遍历


如何将半线性结构转化为线性结构?-通过遍历

对树中的每一个节点都恰好访问一次

任何一个局部的子树
可以分为树根
它的左子树L和它的右子树R三部分
只要根节点的访问
以及左右子树的遍历次序
能够明确确定
那么在整体上就必然导致一个
明确的线性次序


几种典型的遍历算法也就是所谓的先序、中序以及后序,它们的区别其实就在于
局部的根节点究竟是按什么次序来访问的,如果是先于左右子树 那么就是先序
如果是介于左右子树之间,那么就是中序,如果是位于左右子树的遍历之后,那么也就是后序


先序遍历的宏观过程:

整个过程分为两个阶段
首先是自顶而下地依次访问
左侧链上的沿途节点
再倒过来 自底而上地依次遍历
各个层次上的每一棵右子树
这就是我们整个先序遍历的宏观过程

递归算法可以简明实现O(n)的复杂度.

层次遍历中使用到队列,以便是的祖先节点优于后代节点被访问，这不同于
前中后3中遍历，使用了stack。

层次遍历的次序是:自上而下访问各个深度的节点,同样深度的节点中自左向右 

二叉搜索树(BST):在形式上继承了二叉树，也就是列表List结构的特点，同时也巧妙
借鉴了向量，或者准确的讲是有序向量sorted vector的特点和优势，后者更重要，这种
对sorted vector的借鉴是质的提高.这也是bst相对于其他数据结构更为传神的部分.
实际上 BST中所有这些传神的部分
都集中体现在其中的一个子集
也就是平衡二叉搜索树
balanced binary search tree
简称BBST

二叉搜索树也是由一组数据项
所构成的集合

其中每一个数据项
都拥有各自的关键码key
并以此为特征互相区分

关键码与关键码之间
首先应该能够进行比较
也就是判断孰大孰小
其次 还应支持比对
也就是判断两个关键码
是否完全一致

词条也就是entry
究竟是什么呢？
词条结构应该包括以下要素
首先每一个词条的确应该
拥有一个关键码
而词条所包含的其它信息
则笼统地归入一个名为value的域，每一个词条entry
实际上都是由key和value
构成的这么样一个组合
也称作<key value> pair

可以看到
所谓entry之间的比较和比对
按照这种方式
实际上都转化为了词条中
关键码的比较和比对

我们都将二叉搜索树
Binary Search Tree
简称作BST

BST究竟有什么特点和特征呢？
概括起来只有一条
也就是处处满足顺序性
所谓顺序性具体来说就是
相对于某一个节点V而言
如果它的左后代存在
那么所有的左后代
都不致比它更大
对称地 如果它的右后代存在
那么所有的右后代
都不致比它更小

顺序性必须得到满足
这就意味着左子树中的所有的节点
都不致大于树根
而右子树中的所有的节点
也不致于小于树根

BST的中序遍历序列是单调的(单调递增).(以它们的关键码为序)
只要这个序列是单调变化的那么原二叉树就必然是一棵BST.

二叉搜索树的何种遍历序列是递增的(把二叉树投影到水平方向也是递增的-可以理解为有序向量): 中序

在含n个节点的BST中进行查找的最坏时间复杂度为：O(n)

对BST进行插入操作，对待插入的目标元素e进行查找后，若查找失败，_hot指向的节点为：被插入后的父亲

结点的前驱：是该结点的左子树中的最大结点。
结点的后继：是该结点的右子树中的最小结点。

当欲删除的节点v在BST中的度为2时，实际被删除的节点为：v的右子树中左侧分支的最后一个节点

BST是将之前的List和Vector结构的优势结合起来.从策略上 BST可以视作是
试图将此前的向量结构以及列表结构的优势结合起来.
BST各种接口算法的具体实现,概括而言 无论是静态的search操作
还是动态的insert或remove操作,在最坏的情况下 它们所需要的时间,都线性正比于树的高度
比如作为一种极端情况我们假设在一棵BST中所有的节点度数都不超过1,
也就是说 从整体的拓扑结构而言这棵树实际上已经退化成了一条单链(h = n-1),
从逻辑结构看,已经完全退化地等效为一个列表(链表),不难看出 此时整棵树的高度
与整棵树中节点的个数,成线性正比关系,在这种情况下,无论是就平均还是最坏意义而言
静态操作以及动态操作,都需要高达O(n)的时间.

中位数或者接近于中位数的关键码,越是被更早地插入
整体而言 这棵BST的高度,也相应地会更低,这类高度更低的BST
将会被以更高的重复度参与统计,以及最终的平均估算.
但对于在此非常在意树高的我们来说,这并不是一个好消息
这意味着在天然的随机意义下,这样一个高度是不能够令我们满意的
为了进一步地降低和控制这个高度值,我们应该做点什么

什么样的树相对而言高度是更低的,在节点数目相对固定时
左右兄弟子树的高度越是接近,全树通常也会更加倾向于高度更低
也就是说 全树越是接近于平衡,那么它的高度也会倾向于更低
,因此我们可以通过控制全树的平衡度,以控制全树的高度

关于树的高度 我们有这样一个结论
由n个节点所组成的二叉树
其高度最低不会少于log 2为底n的对数
因此如果某棵树的高度
能够达到这样一个理想的下限
我们也称之为理想平衡的二叉树.

那么哪些树能够达到这样的理想平衡状态呢？
完全二叉树 Complete Binary Tree,是的 在这样的树中
叶节点只能出现在最底层以及次底层,当然 其中最好最好不过的
自然是所谓的满二叉树 Full Binary Tree
然而很遗憾 这样一种完美的形式也是难以持续的

因此所谓的理想平衡在实际应用中是不具任何意义的

是的 理想平衡出现的可能性非常非常的低
而且为了维护这样的理想平衡我们的计算成本也相应地会十分的高昂,相对而言 我们会得不偿失

而真正可行的方法是我们或许应该适度地放松平衡的标准
实际上只要能够保证全树的高度
能够从渐近的意义而言不超过O(logn)-这里是以2为底,那么也就可以称之为是平衡的了
因为这种平衡并非严格意义上的理想平衡,所以我们也不妨称之为适度平衡
那么相应地 能够保持适度平衡的BST
也称作平衡的二叉搜索树Balanced Binary Search Tree简称BBST
也就是说 如果将所有的BST,视作一个全集
那么BBST只是其中的一个子集
对于目前而言其中任何一棵BBST
如果经过某次操作之后,它不再保持适度平衡,也就是说 会游离到这个子集之外
我们就需要有一整套方法将这棵BST重新拉回到这个子集中(使用等价转换的方法),使它重新成为一棵BBST

含n个节点，高度为h的BST称为平衡二叉搜索树,它满足:h=O(log2n)

两个等价的平衡二叉搜索树有相同的: 中序遍历序列 

所谓BST 它的本质特征就是处处局部的顺序性以及全局的单调性
具体来说 只需要考察.它的中序遍历序列是否是单调的

2棵bst,拓扑结构不尽相同,但中序遍历序列却相同的,任何一对这样的BST
也就称作相互等价的BST,等价的BST之间
在拓扑结构上 虽然不尽相同,但也有其独特的规律,概括起来有两句话
第一上下可变,在垂直方向有一定的自由度
第二条规律则是左右不能乱,这里的左右自然是指中序遍历序列
确实相对于任何一个节点,居于它右侧的节点
以及居于它左侧的节点之间不能相互混淆
那么在这样一种上下存在一定的调整余地,但左右次序却不得颠倒的规则下
又当如何来实现BST之间的等价转换呢？

等价变换的过程后，无论是局部
还是在它们所属的那棵全树
顺序性和单调性将依然保持
也就是说变换后全树依然将是一棵BST

从效果来看 这样一个变换
可以大致理解为是在此局部围绕着节点V
做了一个顺时针的旋转
我们称这种变换为zig(http://www.xuetangx.com/courses/course-v1:TsinghuaX+30240184_2X+sp/courseware/06d6c305fca54193901007d83cd6e74e/8f1bcfb9768b441fa267610f164f81e6/)
那么这种旋转的中心V 则是zig的参数
右图是完全对称的另一种基本操作
因为它可以理解为是围绕着节点V
做了一次逆时针的旋转操作
我们也形象地称之为zag。

在后续的章节中 我们将会看到
包括AVL树 红黑树在内的
各种BBST都分别精心地
定义了某种适度平衡的准则
从而使得原本在其中的任何一棵BBST
即便在经过某次操作之后
会暂时地游离到这个边界之外
我们也总是能够通过
一系列精巧地等价变换
令它重新回到这个边界以内
并重新成为一棵BBST
而在设计所有这些等价变换的组合时
我们始终不要忘了
应该遵循两个重要的准则
一个就是所谓的局部性
也就是说 我们执行的每一次等价变换
都应该局限在某一常数规模的局部
比如对于我们刚刚介绍的
zig和zag操作而言
它们都局限在局部的V和C两个节点处
如此它们所牵涉到的节点总数既然是常数
这类操作所需要的计算时间
也可以严格地控制在常数的规模O(1)

第二个需要严格遵守的是
在我们将一棵刚刚失衡的BBST
重新恢复为一棵BST的过程中
累计需要执行的
这样的操作的次数不要过多
比如至多不能超过logn次(O(logn))
这样我们就可以有效地控制
整个操作序列的长度
以及总体所需要的时间
后面我们会看到 任何一种BBST
都必须至少满足这样一个logn的基本条件
但是在进一步的要求上
它们各自又有所差异
比如对于AVL树而言
它的删除操作只能刚刚达到这个及格线
而它的插入操作却可以优化到常数O(1)
而我们在第八章中将要介绍的红黑树
也就是Red Black Tree
则可以进一步地将这两种操作的性能
同时提升到最优的常数O(1)

我们来介绍最为经典的一种平衡二叉搜索树(BBST),也就是AVL树

回顾此前的几节我们首先介绍的是,二叉搜索树BST
然而我们也看到,尽管从同时兼顾高效的静态操作
和动态操作的角度讲,BST相对此前简单的向量和列表
已经具有某种优势和潜质,但是毕竟它并不能保证这一点
其原因在于 它的高度,无论是从平均情况 还是最坏情况
都不能保证做到足够的低,具体来说 也就是做到logn以下

当然 在BST中的确存在这么一种特殊的类型
也就是所谓的Complete Binary Tree-完全二叉树,它的高度可以达到严格的最小
也就是logn,然而 相对于整体的BST,这类BST的数量极少
而且我们如果需要将任何一棵树,转化为一棵完全二叉树,所需要的成本也太高
也正因为此,我们的建议是,或许应该适当地放松所谓平衡的标准
也就是说 我们只需考察某一类在渐近意义下不超过,O(logn)高度的树即可
而这样一类树,也就是我们所说的平衡二叉搜索树Balanced Binary Search Tree


比如我们这一节将要介绍的AVL树就是在这种意义下的一种BBST
以AVL树为代表的这些BBST,首先并没有放弃渐近意义logn的复杂度底线,
同时正因为它已经适度地
放松了平衡的标准,对于任何一棵这样意义下的BBST,在其生命期内
即便在某次操作之后,它不再满足BBST的条件,也就是说游离到BBST这个范畴之外
我们也可以通过上节所介绍的等价变换,迅速地将其重新转化为,一棵等价的BBST
也就是说 可以通过极小的代价,就使之重新归入BBST的范畴,而这种极小的代价是多少呢？
不出你的意料 依然是不超过logn

令刚刚失衡的搜索树重新恢复为一棵BBST的过程
也称作重平衡rebalance而对于包括AVL树在内的
各种BBST而言其核心的技巧 无非两条: 第一 如何来界定一种
适度的平衡标准,其次则是一整套重平衡的技巧和算法

### AVL树

什么是AVL树，Adelson-Velsky & E. Landis 取名字的缩写,

在AVL的意义下,什么叫作适度的平衡
凭借什么来判断一棵树,是否是在AVL意义下的适度平衡
我们需要用到这样一个指标,叫平衡因子.

对于二叉树中的任何一个节点v都可以定义它的
所谓平衡因子balanced factor：具体来说 也就是它的左子树高度
与右子树高度之差：balFac(v) = height(lc(v)) - height(rc(v))

平衡因子 = 左子树的高度 - 右子树的高度

那么根据AVL树发明者的定义：
所谓AVL树就是其中所有节点的平衡因子
都不超过1,也不小于-1

AVL树本身只考虑左右子树的高度

对于第一个叶节点而言
它的左右子树都是空(空也就是左右后代都没有，没有后代节点存在,所以人为的人为高度均为-1),高度均为-1
所以这个节点的平衡因子
自然就是-1减-1 零

再来看第二个节点
它的左子树高度为零
而右子树高度为-1
所以它的平衡因子应该为正1


因此对于这样一棵BST来说
平衡因子在处处
都上下不超过正负1
因此它的确是一棵名副其实的AVL树
当然从这个例子 我们也可以看出
AVL树未必是完全二叉树,也就是说 它未必是理想平衡
那么反过来 如此定义的AVL树
是否的确是适度平衡的呢？答案是肯定的。

适度平衡也就是说 一棵规模为n的AVL树
其高度在渐近意义下
是不超过logn的(直接用他当结论)

#### AVL插入


可能同时有多个失衡的节点，最低者g不低于x的祖父.
g经过单旋调整后恢复平衡，子树高度 复原，更高祖先也必平衡，全树复衡.

情况1: 我们在某个节点原本已经更高的分支
插入了一个新的节点
这个分支的高度继续上升一层
从而导致它的平衡因子又减少了1，而且我们假设g是所有因此
而发生失衡的祖先中
最深的那个,也就是最先发生失衡的祖先.
尽管一个节点的插入
有可能会导致多个祖先的失衡
其中最低的那个
也不会低于它的祖父辈.那么既然此处已经发生了失衡
我们又当如何令它重新恢复平衡呢？
实际上 我们能做的无非是上一节
所介绍的等价变换
也就是zig或者是zag旋转.

做一次旋转也就是所谓的单旋.从我们刚才失衡的局部出发,接下来我们要围绕着
失衡的节点g,做一次逆时针的zag旋转,这样的一个旋转
可以由接下来的几步组合完成,首先引入一个临时的引用
指向节点p(parent,当前节点x的父亲),接下来 我们要令p的左子树T1
成为g(祖父)的右子树,为此我们只需这样调整好,再接下来 我们要令g
成为p的左孩子,因此需要做这样的调整,再接下来 我们要将局部子树的根
由g替换为p,此时的临时引用,也完成了历史使命
它可以退出了.如果在此前g以上
还有其它的祖先
同时发生失衡
那么在这个局部重新恢复平衡之后
也会同时一揽子地重新获得平衡

我们无非是做了一次zag旋转
这种旋转只涉及到局部的常数个节点
因此它所对应的时间消耗
应该是O(1)的
这个结果也再好不过了
当然这种情况只是所有情况中的一种
其特点是我们刚才所定义的gpv
这连续三代的节点
在方向上是朝向一致的.

