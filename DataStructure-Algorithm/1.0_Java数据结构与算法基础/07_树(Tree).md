Vector(向量)的Search效率高，insert和remove效率低

List(这里的List指的是链表)的Search效率低，insert和remove效率高.
以上2种结构都是线性结构。

Tree是将Vector和List的优点融合起来，Tree不是线性结构，同时他带有
线性结构的特征，所以我们称树为半线性结构。可以将Tree看作List<List>,或者
List的2次方.Tree可以高效地兼顾静态操作和动态操作。

图是非线性结构.

Tree应该提供的相关的接口:

<table>
	<thead>
		<tr>
			<th>节点</th>
			<th>功能</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>root()</td>
			<td>获取根节点</td>
		</tr>
		<tr>
			<td>parent()</td>
			<td>获取某一个节点的父节点</td>
		</tr>
		<tr>
			<td>firstChild()</td>
			<td>获取某一个节点的第一个孩子</td>
		</tr>
		<tr>
			<td>nextSibling()</td>
			<td>获取某一个节点的下一个兄弟节点</td>
		</tr>
		<tr>
			<td>insert(i, e)</td>
			<td>将e作为某一个节点的第i个孩子插入</td>
		</tr>
		<tr>
			<td>remove(i)</td>
			<td>删除某一个节点的第i个孩子</td>
		</tr>
		<tr>
			<td>traverse()</td>
			<td>遍历</td>
		</tr>
	</tbody>
</table>

元素与元素之间有某种关系,那么我们就引入一条边连接这两个元素.
不存在关系就不引入这样一条边,我们需要为每一棵树指定一个特殊的顶点我们称之为根root

树的边数和tree的顶点的数目是同阶的。
e(edge-边) = n - 1,n为顶点数目.所以在衡量相关复杂度的时候，可以将n作为参考.

顶点共同拥有一个父亲，所以他们之前互称兄弟sibling.

任何一个节点r所拥有的孩子的数目也称作它的度数degree(官方叫出度)。

若指定Ti作为T的第i棵子树，ri作为r的第i个孩子，则T称作有序树.

Tree无环，所以边数不会太大，而且tree是连通的，所以边也不能太少，在保证连通的情况下，能够保证
边数达到最少.

任何一个节点和根节点之前都存在唯一一条通路，这个就是路径的长度.将任何一个节点到root的长度作为一个指标.
称作这个节点在这个树中的深度depth.v的深度depth(v) = path(v),v为顶点(vertex)的缩写.这个路径中的任何一个
节点称做v的祖先(ancestor),v是它们的后代(descendent),

根节点是所有节点的公共祖先，深度为0.

没有后代的节点称为叶子(leaf)-叶子节点.

所有叶子中深度最大的称为tree(或根节点)的高度:height(v)

树的深度(将任何一个节点到root的长度成为这个节点在树中的深度,也就是子树的根节点到全数根节
点的长度称为这棵子树的深度)
和高度(子树中所有叶子，深度最大值成为这个子树的高度)之和不会超过全树的高度.

除根外，任何一个节点有且仅有一个父节点。

用父节点+孩子节点(node -> rank data parent children)的方法存储n个节点的树,需要的空间是:O(n)

长子兄弟法:每个节点只需要记录2个东西，firstChildren(),nextSibling() ,sibling表示同辈节点的水平引用.

### 二叉树(Binary Tree)

每个节点度数(出度)不超过2的tree，

以左右区分:

lChildren() lSubtree()

rChildren() rSubtree()

我们隐含了左在先，右在后的顺序关系，

深度为k的节点，至多2的k次方个节点

含n个节点，高度为h的二叉树中: h < n < 2的(h+1)次方

h<n: 至少在每一层上有一个节点.

1. n = h + 1时: 为单链条(每一层一个节点)

n = 2的(h+1)次方 - 1,为满二叉树，达到饱和状态.

满树的特点是在同样的高度下，顶点数达到最大，也就是饱和状态.

由此可见一棵树在横向上的宽度和纵向上的高度是成指数关系的，宽度是高度的指数.
指数意味着爆炸.意味着剧烈的增长,高度增长的比较缓慢，宽度增长的非常快，也即是对于
二叉树而言，非常倾向于涨宽,它的涨宽的速度更快.这是我们引入二叉搜索树的重要基础.

真二叉树，每个节点的出度是偶数，要么是0，或2

如果某一个节点，原来的度数是0，那么我们就在它的下方
通过增加两个新的孩子，使之变成两度，如果某一个节点原先的度数是1
我们就在缺失的那一侧，同样地引入一个新的孩子节点，从而同样使得它的度数由1变成2
这样一棵新得到的二叉树中，就不再含有1度的节点，我们称这种二叉树为真二叉树，（叶子节点全都是我们虚拟引入的）


重点:

描述多叉树: 可以用长子兄弟法描述.

任何一颗一般性的树均可转化为它的长子兄弟表示法，并且进一步分转化为理解为一颗二叉树.
所以二叉树可以描述多叉树.

只有单个节点的树的高度取0，
根本不存在任何节点的树，也就是空树，空树的高度为-1.

一个节点的高度
之所以会发生变化
是由于它的左孩子
或者右孩子的高度
发生了变化而引起的
准确地讲 一个节点的高度
应该恰好等于它的左孩子
与右孩子高度中的更大者 再加1


二叉树的相关算法
也往往需要对其中的元素按照某种次序
来逐一访问
然而在前面几节我们已经清晰地看到
二叉树已经并非严格意义上的线性结构
至少是所谓的半线性结构

我们如何才能够将二叉树这种半线性结构
转化为此前我们已经相对而言
研究有素的线性结构
具体的来说也就是
按照某种事先约定的原则
在二叉树的所有节点之间
定义某种明确的线性次序
而具体的转换手法
也就是接下来几节要介绍的遍历

实际上 这种策略将贯穿我们整个课程
比如 在接下来一章
将要介绍的图结构
是属于典型的非线性结构
在那里 我们同样面临一个问题
就是如何将非线性结构转化为
又相对而言研究有素的半线性结构
在那里 我们的处理手法
依然是遍历


如何将半线性结构转化为线性结构?-通过遍历

对树中的每一个节点都恰好访问一次

任何一个局部的子树
可以分为树根
它的左子树L和它的右子树R三部分
只要根节点的访问
以及左右子树的遍历次序
能够明确确定
那么在整体上就必然导致一个
明确的线性次序


几种典型的遍历算法也就是所谓的先序、中序以及后序,它们的区别其实就在于
局部的根节点究竟是按什么次序来访问的,如果是先于左右子树 那么就是先序
如果是介于左右子树之间,那么就是中序,如果是位于左右子树的遍历之后,那么也就是后序


先序遍历的宏观过程:

整个过程分为两个阶段
首先是自顶而下地依次访问
左侧链上的沿途节点
再倒过来 自底而上地依次遍历
各个层次上的每一棵右子树
这就是我们整个先序遍历的宏观过程

递归算法可以简明实现O(n)的复杂度.

层次遍历中使用到队列,以便是的祖先节点优于后代节点被访问，这不同于
前中后3中遍历，使用了stack。

层次遍历的次序是:自上而下访问各个深度的节点,同样深度的节点中自左向右 

二叉搜索树(BST):在形式上继承了二叉树，也就是列表List结构的特点，同时也巧妙
借鉴了向量，或者准确的讲是有序向量sorted vector的特点和优势，后者更重要，这种
对sorted vector的借鉴是质的提高.这也是bst相对于其他数据结构更为传神的部分.
实际上 BST中所有这些传神的部分
都集中体现在其中的一个子集
也就是平衡二叉搜索树
balanced binary search tree
简称BBST

二叉搜索树也是由一组数据项
所构成的集合

其中每一个数据项
都拥有各自的关键码key
并以此为特征互相区分

关键码与关键码之间
首先应该能够进行比较
也就是判断孰大孰小
其次 还应支持比对
也就是判断两个关键码
是否完全一致

词条也就是entry
究竟是什么呢？
词条结构应该包括以下要素
首先每一个词条的确应该
拥有一个关键码
而词条所包含的其它信息
则笼统地归入一个名为value的域，每一个词条entry
实际上都是由key和value
构成的这么样一个组合
也称作<key value> pair

可以看到
所谓entry之间的比较和比对
按照这种方式
实际上都转化为了词条中
关键码的比较和比对

我们都将二叉搜索树
Binary Search Tree
简称作BST

BST究竟有什么特点和特征呢？
概括起来只有一条
也就是处处满足顺序性
所谓顺序性具体来说就是
相对于某一个节点V而言
如果它的左后代存在
那么所有的左后代
都不致比它更大
对称地 如果它的右后代存在
那么所有的右后代
都不致比它更小

顺序性必须得到满足
这就意味着左子树中的所有的节点
都不致大于树根
而右子树中的所有的节点
也不致于小于树根

BST的中序遍历序列是单调的(单调递增).(以它们的关键码为序)
只要这个序列是单调变化的那么原二叉树就必然是一棵BST.

二叉搜索树的何种遍历序列是递增的(把二叉树投影到水平方向也是递增的-可以理解为有序向量): 中序

在含n个节点的BST中进行查找的最坏时间复杂度为：O(n)

对BST进行插入操作，对待插入的目标元素e进行查找后，若查找失败，_hot指向的节点为：被插入后的父亲

结点的前驱：是该结点的左子树中的最大结点。
结点的后继：是该结点的右子树中的最小结点。