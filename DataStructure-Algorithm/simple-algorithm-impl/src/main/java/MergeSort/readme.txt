与QuickSort一样，Merge Sort也是一种Divide and Conquer(分而治之)算法。 
Merge Sort是一种递归算法.

归并排序主要由两个方法组成，一个是用于合并两个已经排序的数组的方法，
一个则是递归方法，用于将问题无限拆分。

Tips: 一个数组元素个数是奇数的数组,例如，7个元素,
那么选取的middle元素就正好是正中间的元素.正中间元素的index是:(low + high)/2=3,
即：com.java.algorithm.array[3]

{38, 27, 43, 3, 9, 82, 10}.
 0   1    2  3  4  5    6

如果数组元素的个数是偶数，例如一共6个元素:

{38, 27, 43, 3, 9, 82}.
 0   1    2  3  4  5

那么这个数组就没有正好中间的元素,那么选取的middle元素是 数组对半分成两组后，前一半的最后一个元素:
索引index是: (low + high)/2=2,
即array[2]

所以左指针(左边数组的第一个元素)是low, 右指针(右边数组的第一个元素)是mid+1,即，如果一共7个元素:
中间位置元素索引是: mid = (low + high)/2 = 3, 右指针(左边数组的第一个元素)是: mid + 1 = 4,
如果一共6个元素，那么中间位置元素索引是: mid = (low + high)/2 = 2,
右指针(右边数组的第一个元素)是: mid + 1 = 3.

----------------------------------------------------------------

MergeSort(arr[], l,  r)
If r > l
     1. 找到把数组分成两半的中间点:
             middle m = (l+r)/2
     2. 对第一半调用mergeSort
             Call mergeSort(arr, l, m)
     3. 对第二半调用mergeSort
             Call mergeSort(arr, m+1, r)
     4. 把步骤2和3中的已经排序好的两半进行merge
             Call merge(arr, l, m, r)

----------------------------------------------------------------
比较操作的次数介于(nlogn)/2(nlogn)/2和nlogn−n+1nlogn−n+1。

赋值操作的次数是(2nlogn)(2nlogn)。

空间复杂度为 O(n).
归并排序比较占用内存，但却是一种效率高且稳定的算法。

-----------------------------------------------------------------

冒泡排序和归并排序运行的时间比较,x轴为需要排序的元素的个数，y轴为排好序需要花费的时间.

可以看出，虽然归并排序的运行时间小于冒泡排序，但是在排序数字数目较少时，
冒泡排序的性能要优于归并排序，只是随着元素个数的增加，冒泡排序的时间增加的
比归并排序快.

由此得出以下归并排序的升级版：

设置一个阈值min，当需要排序的数字数目大于min时，继续使用归并排序；
反之，当需要排序的数字数目小于min时，进行冒泡排序。