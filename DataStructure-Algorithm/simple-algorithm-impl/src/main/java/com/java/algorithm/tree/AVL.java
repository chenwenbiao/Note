package com.java.algorithm.tree;

// stature: 身材，个子，个儿

// Balanced(x) : stature((x).lChild) == stature((x).rChild) // 理想平衡

// BalFac(x): stature((x).lChild) - stature((x).rChild) // 平衡因子

// AvlBalanced(x) : (( BalFac(x) > -2 ) && ( BalFac(x) < 2 )) // AVL平衡条件, BalFac(x)最大为1，最小为-1

// 删除操作比插入操作相对更复杂
//插入操作是这样一种孩子
//他有可能在某个时候
//会闯下一连串的祸
//但这个孩子还至少是一个好孩子
//因为他能够痛改前非
//我们很快就会看到
//一旦他能够改正其中的一个错误
//那么其它的一连串错误
//也都会自然地烟消云散
//而反过来 删除操作呢
//虽然不能称作是一个坏孩子
//但是他至少是一个不长记性
//不吸取教训的孩子
//我们很快就会看到
//尽管这个孩子在每一次
//只会闯下一个祸
//但是每当你帮助他
//改正了这个错误之后
//他转眼就会忘掉这件事
//并且很快又会在另一个位置
//犯下同一样的错误
//而且这个孩子的记忆力糟糕之极
//即便你有足够的耐心
//帮助他改正下一个错误
//接下来转眼之间
//他又有可能在另一个位置
//再次犯下同样的错误
//因此相对而言
//插入操作实际上要更为简便一些
//而删除操作要复杂不少
public abstract class AVL<T extends Comparable<T>> extends BST<T>{// 由BST派生

    // search()等接口可以直接沿用

    // 需要重写的是动态的插入和删除操作

    /**
     * 插入一个节点之后,有可能会导致若干个祖先失衡
     * 当然你大可放心,除了祖先之外的其它节点
     * 是不可能失衡的其背后的原因在于,对于非新插入节点
     * 祖先的那些节点而言,无论是它们的高度,还是它们孩子的高度
     * 都不会因为新节点的插入而有所变化,所以它们各自的平衡因子
     * 也都将维持原状,如果此前是平衡的,那么它们就不可能变成失衡
     *
     *
     * @param e
     * @return
     */
    boolean insert(T e){
        return false;
    }

    /**
     * 因为对于删除操作来说在摘除节点之后的瞬间
     * 至多只有一个节点会失衡
     * 为此我们不妨考察其中高度最低的那个失衡祖先
     * 我们会发现这个祖先尽管失衡了
     * 它的高度却必然保持原样,这背后的原因在于
     * 如果这个节点的失衡的确是因为,它的某个后代被摘除了
     * 那么这个后代在此前也必然属于它那个相对更短的分支
     * 而它的高度则是由它相对更长的那些分支所决定的
     * 因此这个节点的删除并不致于引起这个祖先高度的变化
     * 而既然这个祖先的高度不致于变化,那么相对于更高的祖先而言
     * 它们在计算平衡因子时结果也应该与未删除节点之前是一样的
     * 换而言之 它们也必然是平衡的
     *
     * 所以概括而言
     * 如果在一棵AVL树中
     * 删除某个节点之后
     * 的确引起祖先的失衡
     * 那么这种失衡的祖先
     * 充其量不过只有一个
     * @param e
     * @return
     */
    boolean remove(T e) {
        return false;
    }

}
