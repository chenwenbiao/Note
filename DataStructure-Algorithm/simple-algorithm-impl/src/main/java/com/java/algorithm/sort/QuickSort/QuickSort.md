## 快速排序

毫无疑问，快速排序(quick sort)是最流行的排序算法，因为有充足的理由，`在大多数情况下，快速排序都是最快的，执行时间为O(n*logn) 级.`

快速排序算法本质上通过把一个数组划分(patition)为两个子数组，然后递归地调用自身，将子数组划分为更细的子数组，为每一个子数组进行快速排序来实现的。

在前面讲解的归并排序(merge sort)中，实际上也是对数组进行进行拆分，然后进行排序，快速排序和归并排序都是分治法的典型应用。 不过不同的是，二者的划分标准不同：

在归并排序中，是将数组不断的划分成两个大小相同的子数组，实际上就是取数组下标的中间值进行拆分，例如{3,1,9,0,4,7,2,6,5,8}划分后的结果为{3,1,9,0,4 }和{7,2,6,5,8}

而在快速排序中，数组的划分是基于某一个基准值(pivot)的，拆分时，将所有大于基准值的元素放在一组，将所有小于基准值的元素放在另一组。 比如基准值为5，那么{3,1,9,0,4,7,2,6,5,8}划分后的结果为{3, 1, 2, 0, 4}和{7, 9, 6, 5, 8}

需要注意的是，归并排序由于是根据数组下标中间值划分的，因此切分后的两个子数组的长度最多相差1，但是对于快速排序，由于是根据基准值来进行划分，如果基准值选择的不好，例如基准值等于1，那么{3,1,9,0,4,7,2,6,5,8}划分后的结果为{1}和{3,9,0,4,7,2,6,5,8 }，因此在快速排序中，我们需要对划分操作有特别的关注。

划分

划分是快速排序的根本机制，依赖于基准值。划分数据就是把数据分成两组，所有大于基准值的数据在一组，所有小于基准值的在一组。比如基准值为5，那么{3,1,9,0,4,7,2,6,5,8}划分后的结果为{3, 1, 2, 0, 4 }和{7, 9, 6, 5, 8}。

理论上，可以使用任何值作为基准值，这个值可以包含在要排序的数组中，也可以是其他任意数字，基准值选择的有一定的技巧，如果选择的基准值比数组中任意一个元素都要大或者小的话，那么就相当于没有进行划分，最简单的基准值的选择方法，就是从数组中随机选择一个元素，当做基准值。

划分算法由两个指针来完成，这两个指针分别指向数组的开始和结尾，左指针left pointer向右移动而右指针right pointer向左移动.如图:![](01.png)

停止和交换

当left pointer 遇到比基准值小的值时它继续右移，因为这个数据项的位置已经在数组的小于基准值得一边了。当遇到基准值大的数时，它就停下来。

类似的，当right pointer 遇到比特定值大的数时就继续左移，当遇到比基准值小的数时就停下来。当都停下来的时候left pointer 和right pointer 都指向了在数组错误一方位置上的数据项，所以交换这两个数据项。

交换之后，继续移动两个指针，然后再在合适的实际停止、交换数据，不断重复此过程。

当right pointer和left pointer相遇时，划分完成。

![](划分过程图解.png)

在第一次划分时，left pointer需要在一个比自己大的位置上停下来，9是第一个数字，所以此时left pointer指向9，right pointer需要在第一个比自己小的位置上停下来，所以right pointer指向2，此时交换两个指针位置指向的数字，即9和2的位置。

第二次划分时，left pointer继续右移，遇到7，比自己大，停下来；此时right pointer右移，也到了7的位置，两个指针相遇，划分完成。 此时在相遇数组下标左边的元素，都比基准值5小，而相遇下标右边的元素都大于等于基准值5，划分因此完成。


### 快速排序算法

基本的快速排序很简单，就是对一个数组进行不断的进行划分操作，当划分操作完成时，排序也就完成了，听起来不可思议，但是事实就是这样。

每一次划分(partition)操作，在快速排序中称之为一趟，我们可以通过将上面划分后的两个子数组，再分别进行一趟快速排序。

![](02.png)

每个子数组在继续进行划分的时候，需要重新选择基准值，也就是每一趟都需要重新选择一个基准值，为了方便，我们通常选择划分后的子数组的第一个元素作为基准值，因此左半部分的基准值是3，右半部分的基准值是7(感兴趣的读者，可以尝试继续用画图的方式进行逐步推导)。

当划分后的子数组只剩一个元素时，划分结束。