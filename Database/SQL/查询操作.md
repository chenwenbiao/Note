持久化(Persistence): 简单说就是就是数据保存到硬盘.，即把数据(如内存中的对象）保存到可永久保存的存储设备中(如磁盘). 通俗的讲，就是瞬时数据(比如内存中的数据，是不能永久保存的）持久化为持久数据(比如持久化至数据库中，能够长久保存）。

在关系数据库中，最常用的操作就是查询。

MySQL的持久化存储.

```
SELECT 100+200;

> 300
```

> 虽然SELECT可以用作计算，但它并不是SQL的强项。但是，不带FROM子句的SELECT语句有一个有用的用途，就是用来判断当前到数据库的连接是否有效。许多检测工具会执行一条SELECT 1;来测试数据库连接。

SELECT查询的结果是一个二维表。

### 条件查询

获取所有记录不仅费时，还费内存和网络带宽,所以就有条件查询.通过WHERE条件查询，可以筛选出符合指定条件的记录，而不是整个表的所有记录。

>条件查询的语法就是：`SELECT * FROM <表名> WHERE <条件表达式>`

条件表达式分为:

* `<条件1> AND <条件2>`: 表达满足条件1并且满足条件2.
* `<条件1> OR <条件2>`，表示满足条件1或者满足条件2.
* NOT <条件>: 表示“不符合该条件”的记录.
* 要组合三个或者更多的条件，就需要用小括号()表示如何进行条件运算.
* 如果不加括号，条件运算按照NOT、AND、OR的优先级进行，即NOT优先级最高，其次是AND，最后是OR。加上括号可以改变优先级。

1. `SELECT * FROM students WHERE score >= 80 AND gender = 'M';`
2. `SELECT * FROM students WHERE score >= 80 OR gender = 'M'`;
3. `SELECT * FROM students WHERE NOT class_id = 2;`(不是2班的学生)
4. `SELECT * FROM students WHERE class_id <> 2;`
5. `SELECT * FROM students WHERE (score < 80 OR score > 90) AND gender = 'M';`
6. `SELECT * FROM students WHERE name LIKE '小%';`

> 上述NOT条件NOT class_id = 2其实等价于class_id <> 2，因此，NOT查询不是很常用。

#### 常用的条件表达式

条件              表达式举例1          表达式举例2      说明
使用=判断相等      score = 80          name = 'abc'    字符串需要用单引号括起来
使用>判断大于      score > 80         name > 'abc' 字符串比较根据ASCII码，中文字符比较根据数据库设置
使用>=判断大于或相等 score >= 80         name >= 'abc'   
使用<判断小于       score < 80        name < 'abc'   
使用<=判断小于或相等 score <= 80         name <= 'abc'   
使用<>判断不相等     score <> 80       name <> 'abc'   
使用LIKE判断相似    name LIKE 'ab%'    name LIKE '%bc%'    %表示任意字符，  例如'ab%'将匹配'ab'，'abc'，'abcd'(%表示0个到多个，_表示1个)

### 投影查询

使用`SELECT * FROM <表名> WHERE <条件>`返回的二维表结构和原表是相同的，即结果集的所有列与原表的所有列都一一对应。

>使用SELECT *表示查询表的所有列,如果只希望返回某些列，而不是所有列，我们可以用SELECT 列1, 列2, 列3 FROM ...，让结果集仅包含指定列。这种操作称为投影查询。

`SELECT id, score, name FROM students;`

>这样返回的结果集的列的顺序和原表可以不一样。

给每一列起个别名:`SELECT 列1 别名1, 列2 别名2, 列3 别名3 FROM ...;`

id和name列名保持不变,score重命名为points：`SELECT id, score points, name FROM students;`

投影查询同样可以接WHERE条件，实现复杂的查询：
`SELECT id, score points, name FROM students WHERE gender = 'M';`

### 排序

用SELECT查询时，查询结果集通常是按照id排序的，也就是根据主键排序。这也是大部分数据库的做法。如果我们要根据其他条件排序怎么办？可以加上ORDER BY子句。例如按照成绩从低到高进行排序：

`SELECT id, name, gender, score FROM students ORDER BY score;`

我们可以加上DESC表示“降序”:

`SELECT id, name, gender, score FROM students ORDER BY score DESC;`

如果score列有相同的数据，要进一步排序，可以继续添加列名。例如，使用ORDER BY score DESC, gender表示先按score列倒序，如果有相同分数的，再按gender列排序：

`SELECT id, name, gender, score FROM students ORDER BY score DESC, gender;`

>默认的排序规则是ASC：“升序”，即从小到大。ASC可以省略，即ORDER BY score ASC和ORDER BY score效果一样。

如果有WHERE子句，那么ORDER BY子句要放到WHERE子句后面:

`SELECT id, name, gender, score FROM students WHERE class_id = 1 ORDER BY score DESC;`

### 分页查询

使用SELECT查询时，如果结果集数据量很大，放在一个页面显示的话数据量太大，不如分页显示，每次显示100条。要实现分页功能，实际上就是从结果集中显示第1~100条记录作为第1页，显示第101~200条记录作为第2页，以此类推。

因此，分页实际上就是从结果集中“截取”出第M~N条记录。这个查询可以通过`LIMIT <M> OFFSET <N>`子句实现。我们先把所有学生按照成绩从高到低进行排序：

`SELECT id, name, gender, score FROM students ORDER BY score DESC LIMIT 3 OFFSET 0;`

>对结果集从0号记录开始，最多取3条。注意SQL记录集的索引从0开始。

如果要查询第2页，那么我们只需要“跳过”头3条记录，也就是对结果集从3号记录开始查询，把OFFSET设定为3：

`SELECT id, name, gender, score FROM students ORDER BY score DESC LIMIT 3 OFFSET 3;`

分页查询的关键在于:`首先要确定每页需要显示的结果数量pageSize(这里是3），然后根据当前页的索引pageIndex(从1开始），确定LIMIT和OFFSET应该设定的值`：

1. LIMIT总是设定为pageSize；
2. OFFSET计算公式为pageSize * (pageIndex - 1)。

这样就能正确查询出第N页的记录集。

>分页查询需要先确定每页的数量和当前页数，然后确定LIMIT和OFFSET的值。

如果原本记录集一共就10条记录，但我们把OFFSET设置为20，会得到什么结果呢？

`SELECT id, name, gender, score FROM students ORDER BY score DESC LIMIT 3 OFFSET 20;`

>OFFSET超过了查询的最大数量并不会报错，而是得到一个空的结果集。

#### 注意

1. OFFSET是可选的，如果只写LIMIT 15，那么相当于LIMIT 15 OFFSET 0。
2. 在MySQL中，LIMIT 15 OFFSET 30还可以简写成LIMIT 30, 15。
3. 使用LIMIT <M> OFFSET <N>分页时，随着N越来越大，查询效率也会越来越低。

### 聚合查询

>对于统计总数、平均数这类计算，SQL提供了专门的聚合函数，使用聚合函数进行查询，就是聚合查询，它可以快速获得结果。

查询students表一共有多少条记录:`SELECT COUNT(*) FROM students;`

>COUNT(*)表示查询所有列的行数，要注意聚合的计算结果虽然是一个数字，但查询的结果仍然是一个二维表，只是这个二维表只有一行一列，并且列名是COUNT(*)。通常，使用聚合查询时，我们应该给列名设置一个别名，便于处理结果：

使用聚合查询并设置结果集的列名为num:`SELECT COUNT(*) num FROM students;`

>COUNT(*)和COUNT(id)实际上是一样的效果。另外注意，聚合查询同样可以使用WHERE条件，因此我们可以方便地统计出有多少男生、多少女生、多少80分以上的学生等：

`SELECT COUNT(*) boys FROM students WHERE gender = 'M';`

>除了COUNT()函数外，SQL还提供了如下聚合函数：

函数  说明
SUM  计算某一列的合计值，该列必须为`数值类型`
AVG  计算某一列的平均值，该列必须为`数值类型`
MAX  计算某一列的最大值
MIN  计算某一列的最小值

>注意，MAX()和MIN()函数并不限于数值类型。如果是字符类型，MAX()和MIN()会返回排序最后和排序最前的字符。

要统计男生的平均成绩:`SELECT AVG(score) boys_avg_score FROM students WHERE gender = 'M';`

>要特别注意：如果聚合查询的WHERE条件没有匹配到任何行，COUNT()会返回0，而SUM()、AVG()、MAX()和MIN()会返回NULL,例如:`SELECT AVG(score) avg FROM students WHERE gender = 'X';`

#### 分组

SQL还提供了“分组聚合”的功能,例如统计一班，二班，三班的学生:`SELECT COUNT(*) num FROM students GROUP BY class_id;`

>执行这个查询，COUNT()的结果不再是一个，而是3个，这是因为，GROUP BY子句指定了按class_id分组，因此，执行该SELECT语句时，会把class_id相同的列先分组，再分别计算，因此，得到了3行结果。但是这3行结果分别是哪三个班级的，不好看出来，所以我们可以把class_id列也放入结果集中：`SELECT class_id, COUNT(*) num FROM students GROUP BY class_id;`

`SELECT name, class_id, COUNT(*) num FROM students GROUP BY class_id;`

>不出意外，执行这条查询我们会得到一个语法错误，因为在任意一个分组中，只有class_id都相同，name是不同的，`SQL引擎不能把多个name的值放入一行记录中`。因此，聚合查询的列中，只能放入分组的列。

也可以使用多个列进行分组。例如，我们想统计各班的男生和女生人数：

`SELECT class_id, gender, COUNT(*) num FROM students GROUP BY class_id, gender;`

请使用一条SELECT查询查出每个班级的平均分：`SELECT class_id, AVG(score) avg_score FROM students GROUP BY class_id;`

请使用一条SELECT查询查出每个班级男生和女生的平均分：`SELECT class_id, gender, AVG(score) avg_score FROM students GROUP BY class_id, gender;`

### 多表查询

>SELECT查询不但可以从一张表查询数据，还可以从多张表同时查询数据。查询多张表的语法是：SELECT * FROM <表1> <表2>。

`SELECT * FROM students, classes;`

>这种一次查询两个表的数据，查询的结果也是一个二维表，它是students表和classes表的“乘积”，即students表的每一行与classes表的每一行都两两拼在一起返回。结果集的列数是students表和classes表的列数之和，行数是students表和classes表的行数之积。

>这种多表查询又称笛卡尔查询，使用笛卡尔查询时要非常小心，由于结果集是目标表的行数乘积，对两个各自有100行记录的表进行笛卡尔查询将返回1万条记录，对两个各自有1万行记录的表进行笛卡尔查询将返回1亿条记录。

上述查询的结果集有两列id和两列name，两列id是因为其中一列是students表的id，而另一列是classes表的id，但是在结果集中，不好区分。两列name同理,要解决这个问题，我们仍然可以利用投影查询的“设置列的别名”来给两个表各自的id和name列起别名：

`SELECT 
        students.id sid, 
        students.name name, 
        students.gender gender, 
        students.score score, 
        classes.id cid, 
        classes.name cname 
FROM students, classes;`

多表查询时，要使用表名.列名这样的方式来引用列和设置别名，这样就避免了结果集的列名重复问题。但是，用表名.列名这种方式列举两个表的所有列实在是很麻烦，所以SQL还允许给表设置一个别名，让我们在投影查询中引用起来稍微简洁一点：

`SELECT 
        s.id sid,
        s.name name,
        s.gender gender,
        s.score score,
        c.id cid,
        c.name, cname
FROM students s, classes c;`

注意到FROM子句给表设置别名的语法是FROM <表名1> <别名1>, <表名2> <别名2>。这样我们用别名s和c分别表示students表和classes表。

多表查询也是可以添加WHERE条件的，我们来试试：

`SELECT s.id sid, s.name name, s.gender gender, s.score score, c.id cid, c.name cname FROM students s, classes c WHERE s.gender = 'M' AND c.id = 1;`

添加WHERE条件后结果集的数量大大减少了。

* 使用多表查询可以获取M x N行记录；
* 多表查询的结果集可能非常巨大，要小心使用。

### 连接查询

>连接查询是另一种类型的多表查询。连接查询对多个表进行JOIN运算，就是先确定一个主表作为结果集，然后，把其他表的行有选择性地“连接”在主表结果集上。

#### 4种连接查询的区别

SELECT ... FROM tableA ??? JOIN tableB ON tableA.column1 = tableB.column2;
我们把tableA看作左表，把tableB看成右表:

**INNER JOIN**

我们希望结果集同时包含"学生姓名"以及"这个学生所在班级的名称"，上面的结果集只有class_id列，缺少对应班级的name列。现在问题来了，存放班级名称的name列存储在classes表中，只有根据students表的class_id，找到classes表对应的行，再取出name列，就可以获得班级名称。
我们先使用最常用的一种内连接——INNER JOIN来实现：

```sql
`SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s INNER JOIN classes c ON s.class_id = c.id;`
```

注意INNER JOIN查询的写法是：

1. 先确定主表，仍然使用FROM <表1>的语法；
2. 再确定需要连接的表，使用INNER JOIN <表2>的语法；
3. 然后确定连接条件，使用ON <条件...>，这里的条件是s.class_id = c.id，表示students表的class_id列与classes表的id列相同的行需要连接；
4. 可选：加上WHERE子句、ORDER BY等子句。

>使用别名不是必须的，但可以更好地简化查询语句。

INNER JOIN只返回同时存在于两张表的行数据，由于students表的class_id包含1，2，3，classes表的id包含1，2，3，4，所以，INNER JOIN根据条件s.class_id = c.id返回的结果集仅包含1，2，3。

>INNER JOIN是选出两张表都存在的记录.(两表的交集)

**RIGHT OUTER JOIN(简写:RIGHT JOIN)**

```sql
`SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
RIGHT OUTER JOIN classes c
ON s.class_id = c.id;`
```
RIGHT OUTER JOIN多了一行，多出来的一行是“四班”，但是，学生相关的列如name、gender、score都为NULL。
,这也容易理解，因为根据ON条件s.class_id = c.id，classes表的id=4的行正是“四班”，但是，students表中并不存在class_id=4的行。

RIGHT OUTER JOIN返回右表(本例中即classes表)都存在的行。如果某一行仅在右表存在，那么结果集就会以NULL填充剩下的字段(注意左表中存在但是右表中不存在的行不会被查询出来.例如本例中的students中的class_id=5的行就不会被查询出来.)

>RIGHT OUTER JOIN(简写:RIGHT JOIN)是选出右表存在的记录,

**LEFT OUTER JOIN(缩写:LEFT JOIN)**

LEFT OUTER JOIN则返回左表(本例中为students表)都存在的行。如果我们给students表增加一列，并添加class_id=5，由于classes表并不存在id=5的列，所以，LEFT OUTER JOIN的结果会增加一列，对应的classes表中的class_name是NULL.

>LEFT OUTER JOIN(缩写:LEFT JOIN)是选出左表存在的记录.

```sql
`SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
LEFT OUTER JOIN classes c
ON s.class_id = c.id;`
```

**FULL OUTER JOIN**

FULL OUTER JOIN,它会把两张表的所有记录全部选择出来，并且自动把对方不存在的列填充为NULL

```sql
`SELECT s.id, s.name, s.class_id, c.name class_name, s.gender, s.score
FROM students s
FULL OUTER JOIN classes c
ON s.class_id = c.id;`
```

>FULL OUTER JOIN则是选出左右表都存在的记录,不存在的用NULL补上.

>注意:mysql不支持全外连接.