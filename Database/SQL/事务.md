在执行SQL语句的时候，某些业务要求，一系列操作必须全部执行，而不能仅执行一部分。例如，一个转账操作：

```sql
-- 从id=1的账户给id=2的账户转账100元
-- 第一步：将id=1的A账户余额减去100
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- 第一步：将id=1的A账户余额减去100
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
```

>这两条SQL语句必须全部执行，或者，由于某些原因，如果第一条语句成功，第二条语句失败，就必须全部撤销。

这种把多条语句作为一个整体操作的功能，被称为数据库的事务.数据库的事务可以确保该事务范围内的所有操作都可以全部成功或全部失败，如果事务失败，那么效果就和没有执行这些SQL语句一样，不会对数据库有任何改动.

>可见，数据库事务具有ACID这4个特性：

1. A:Atomic,原子性，将“所有的SQL”作为原子工作单元执行(也就是这一堆sql语句是一个原子单元，不可分割)，要么全部执行，要么全部不执行.
2. C:Consistent,一致性，事务完成后，所有的数据状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；
3. I:Isolation,隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；
4. D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。

### 隐式事务

对于单条SQL语句，数据库系统自动将其作为一个事务执行，这种事务被称为隐式事务。

### 显示事务

要手动把多条SQL语句作为一个事务执行，使用BEGIN开启一个事务，使用COMMIT提交一个事务，这种事务被称为显式事务:

```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```

>很显然多条SQL语句要想作为一个事务执行，就必须使用显式事务。

COMMIT是指提交事务，即试图把事务内的所有SQL所做的修改永久保存，如果COMMIT语句执行失败了，那么整个事务也会失败。

主动让事务失败，这时我们可以用ROLLBACK回滚事务，整个事务会失败:

```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
ROLLBACK;
```

>数据库事务是由数据库系统保证的，我们只需要根据业务逻辑使用它就可以。

### 隔离级别

对于两个并发执行的事务，`如果涉及到操作同一条记录的时候`，可能会发生问题，因为并发操作会带来数据的不一致性，包括脏读，不可重复读，幻读等.
数据库系统提供了`隔离级别`来让我们`有针对性的选择事务的隔离级别`，避免数据不一致的问题.

>SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：

IsolationLevel 脏读(Dirty Read)  不可重复读(Non Repeatable Read) 幻读(Phantom Read)
Read Uncommitted  Yes               Yes                         Yes
Read Committed      -               Yes                         Yes
Repeatable Read     -               -                           Yes
Serializable        -               -                           -

>我们会依次介绍4种隔离级别的数据一致性问题。

查看当前数据库事务的隔离级别(ISOLATION LEVEL):`SELECT @@TX_ISOLATION;` or `SHOW VARIABLES LIKE 'tx_isolation';`

