mysql登录:`mysql -h hostname -u root -p`

数据库备份:`mysqldump -u root -p1 test > d:\test.sql`

数据库恢复:`mysql> source d:\test.sql` or `mysql -u root -p < schema.sql`

创建数据库:`CREATE DATABASE if not exists <dbname> CHARACTER SET utf8mb4;`

查看创建数据库的SQL语句:`show create database db;`

删除数据库:`drop database if exists <db_name>;`

>注意：删除一个数据库将导致该数据库的所有表全部被删除。

列出当前数据库的所有表，使用命令：`SHOW TABLES;`

要查看一个表的结构，使用命令：`DESC students;`

查看创建表的SQL语句:`SHOW CREATE TABLE students;`

删除表使用DROP TABLE语句：`DROP TABLE students;`

**表的管理**

```sql
--创建表
CREATE TABLE IF NOT EXISTS stuinfo(
    stuId INT,
    stuName VARCHAR(20),
    gender CHAR,
    bornDate DATETIME);

DESC studentinfo;
--修改表 alter
ALTER TABLE 表名 ADD|MODIFY|DROP|CHANGE COLUMN 字段名 【字段类型】;
--修改字段名
ALTER TABLE studentinfo CHANGE  COLUMN sex gender CHAR;
--修改表名
ALTER TABLE stuinfo RENAME [TO]  studentinfo;
--修改字段类型和列级约束
ALTER TABLE studentinfo MODIFY COLUMN borndate DATE ;
--添加字段
ALTER TABLE studentinfo ADD COLUMN email VARCHAR(20) first;
--删除字段
ALTER TABLE studentinfo DROP COLUMN email;
--删除表
DROP TABLE [IF EXISTS] studentinfo;
```

修改表就比较复杂。如果要给students表新增一列birth:`ALTER TABLE students ADD COLUMN birth VARCHAR(10) NOT NULL;`

要修改birth列，例如把列名改为birthday，类型改为VARCHAR(20)：`ALTER TABLE students CHANGE COLUMN birth birthday VARCHAR(20) NOT NULL;`

删除列使用:`ALTER TABLE students DROP COLUMN birthday;`

如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用REPLACE语句，这样就不必先查询，再决定是否先删除再插入：`REPLACE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小明', 'F', 99);`

>若id=1的记录不存在，REPLACE语句将插入新记录，否则，当前id=1的记录将被删除，然后再插入新记录。

如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用INSERT INTO ... ON DUPLICATE KEY UPDATE ...语句：
`INSERT INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小红', 'F', 88) ON DUPLICATE KEY UPDATE name='小艳', gender='F', score=89;`

>若id=1的记录不存在，INSERT语句将插入新记录，否则，当前id=1的记录将被更新，更新的字段由UPDATE指定。

如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用INSERT IGNORE INTO ...语句：`INSERT IGNORE INTO students (id, class_id, name, gender, score) VALUES (1, 1, '小张', 'M', 60);`

>若id=1的记录不存在，INSERT语句将插入新记录，否则，不执行任何操作。

>如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合CREATE TABLE和SELECT:

```sql
-- 对class_id=1的记录进行快照，并存储为新表students_of_class1:
-- 新创建的表结构和SELECT使用的表结构完全一致。
CREATE TABLE students_of_class1 SELECT * FROM students WHERE class_id=1;
```

如果查询结果集需要写入到表中，可以结合INSERT和SELECT，将SELECT语句的结果集直接插入到指定表中.

创建一个统计成绩的表statistics，记录各班的平均成绩：

```sql
CREATE TABLE statistics (
	id BIGINT NOT NULL AUTO_INCREMENT,
	class_id BIGINT NOT NULL,
	average DOUBLE NOT NULL,
	PRIMARY KEY (id)
);
```

然后，我们就可以用一条语句写入各班的平均成绩：
`INSERT INTO statistics (class_id, average) SELECT class_id, AVG(score) FROM students GROUP BY class_id;`

>确保INSERT语句的列和SELECT语句的列能一一对应，就可以在statistics表中直接保存查询的结果.

**使用truncate语句删除**

```sql
-- 清空表的内容
truncate table 表名
```

**delelte和truncate区别**

- truncate不能加where条件，而delete可以加where条件
- truncate的效率高一丢丢
- truncate删除不能回滚，delete删除可以回滚






















ALTER DATABASE <DBNAME> CHARACTER SET utf8 COLLATE utf8_general_ci;

desc tableName;
rename table t to t1;
drop table t3;
alter table small change column STBMAC id text;
ALTER TABLE table_name ADD column_name datatype;
alter table t add age int;
alter table t drop id;
alter table t modify age tinyint;
alter table t change column name username varchar(30);
删除主键：alter table stu drop primary key;

清空表中的所有数据: delete from <tablename>
```

* 删除主键之前一定要删除当前主键的外键约束
* not null 非空约束，此字段值不能为空
* unique 唯一约束，此字段值必须唯一，但可以为空

#### 字符集(CHARACTER SET)

无论哪种文字，日文，韩文，中文，英文，在计算机上存储的时候都是0和1构成.

查看当前数据库的字符集:` show variables like 'char%'`,
查看Mysql的支持的所有字符集:`SHOW CHARACTER SET;`，`每种字符集中字符串最多能占有的字节数`不同，utf8(注意utf8是使用Unicode方式编码的)这种字符集的每个字符`最多`能占有3个字节，utf8mb4这种字符集的每个字符`最多`占有4个字节.(CHARACTER SET中的Maxlen就代表了每个字符不一定非占满，有的字符占的字节多，有的少)

>某些字符集(例如utf8)包含了多字节字符，但某个字符串可能只包含单字节字符.例如中文在utf8字符集中.

MySQL提供了LENGTH函数来获取`一个字符串占有多少个字节`，CHAR_LENGTH函数用于获取`字符串的长度`，如果字符串中的`某个字符占有多个字节`，则LENGTH函数的结果大于CHAR_LENGTH()函数的结果，例如:

```sql
SET @str = CONVERT('MySQL' USING ucs2);
-- ucs2这种字符集的每个字符占有的字节数是2
SELECT LENGTH(@str), CHAR_LENGTH(@str);
```

得到: LENGTH(@str)=10,  CHAR_LENGTH(@str)=5,
即：字符串长度为5，这个字符串占有的字节数为10.

>CONVERT函数将字符串转换为指定的字符集.

##### 设置客户端连接的字符集

1. 客户端连接到MySQL数据库服务器后发出SET NAME语句。 例如，要设置字符集为使用Unicode编码的utf8字符集，请使用以下语句：`SET NAMES 'utf8';`
2. mysql客户端工具支持--default-character-set，您可以在配置文件中进行如下设置：
```
[mysql]
default-character-set=utf8
```
3. 一些MySQL连接器允许您设置字符集，例如:项目中的application-dev.yml:`url: jdbc:mysql://127.0.0.1:3306/bootdo?useUnicode=true&characterEncoding=utf8`
4. 无论使用哪种方式，请确保`应用程序使用的字符集`与`存储在MySQL数据库服务器`中的字符集匹配。
5. 设置客户端的字符集为gbk:`set character_set_client = 'gbk';`
6. 设置结果集的字符集为gbk:`set character_set_results = 'gbk';`
7. character_set_client：`客户端请求数据的字符集`
8. character_set_connection:连接层字符集
9. character_set_database：默认数据库的字符集，无论默认数据库如何改变，都是这个字符集；如果没有默认数据库，那就使用 character_set_server指定的字符集，这个变量建议由系统自己管理，不要人为定义。
10. character_set_results：结果集，返回给客户端的字符集
11. character_set_server：数据库服务器的默认字符集

>直接在cmd命令行设置的编码是session级别的。也就是说，我们设置的编码只在当前会话起作用。关闭掉当前会话，重新开启，设置就会失效。如果设置多个会话的字符集那么需要设置global范围:Set [global|session] variables …(不论设置session级别的还是global级别的，重启sql以后，都会失效.)

### 校对规则

查看当前数据库的校对规则:`show variables like 'collation%';`
查看数据库中所有的校对规则: `show collation;`

>Collation校对规则：负责决定某一字符集下的字符进行比较和排序的结果。

创建一个数据库db2,字符集用gbk，校对规则用gbk_bin
create database db1 character set gbk collate gbk_bin;

查看中文校对规则
show collation like '%gb%';

show variables like 'validate_password%';

set global validate_password_length = 6;

Enter the following if the database user already exists.:

GRANT SELECT ON database.* TO user@'localhost';

To enable more options, you would separate them with a comma. So to enable SELECT, INSERT, and DELETE your syntax would look like this:

GRANT SELECT, INSERT, DELETE ON database TO username@'localhost' IDENTIFIED BY 'password';

#### 三，多表查询

##### 1，交叉查询

```shell
select * from stu cross join score;
select * from stu,score;
```

##### 2, 内连接

* 显式内连接

```shell
select * from stu s inner join score c on s.id = c.id;
```

* 隐式内连接

```shell
select * from stu s ,score c where s.id = c.id;
```

##### 3, 外连接

* 左外连接(left out join）

* 右外连接(right outer join）

> 与内连接不同的是，外连接不仅返回连接表中符合连接条件及查询条件的数据行，也返回左
表(左外连接时）或右表(右外连接时）中仅符合查询条件但不符合连接条件的数据行

```shell
select * from stu s left outer join score c on s.id = c.sid;
```

##### 4, 子查询

```shell
select * from stu where id not in(select sid from score);
```

##### 5, 联合查询

```shell
select * from stu where id = 1 union select * from stu where address = '桃花岛';
```

##### 6, 报表查询

```shell
select count(*) 人数, sex from stu group by sex having  count(*) > 2;
```

#### 四, 合计函数(聚合函数）

返回某一列，行的总数:
```shell
select count(id) from stu;
```

sum(english)：统计英语总分，返回满足where条件的行的和
```shell
select sum(chinese) 语文总分 form score;
```

avg(english):返回满足where条件的一列的平均值
```shell
select avg(chinese) from score;
```

Max/min函数返回满足where条件的一列的最大/最小值
```shell
select max(chinese) from score; select min(chinese) from score;
```

### 关于编码

MySQL 的「utf8」实际上不是真正的 UTF-8。

「utf8」只支持每个字符最多三个字节，而真正的 UTF-8 是每个字符最多四个字节。MySQL 一直没有修复这个 bug，他们在 2010 年发布了一个叫作「utf8mb4」的字符集，绕过了这个问题。当然，他们并没有对新的字符集广而告之(可能是因为这个 bug 让他们觉得很尴尬），以致于现在网络上仍然在建议开发者使用「utf8」，但这些建议都是错误的。

简单概括如下：

1. MySQL 的「utf8mb4」是真正的「UTF-8」。
2. MySQL 的「utf8」是一种「专属的编码」，它能够编码的 Unicode 字符并不多。

我要在这里澄清一下：所有在使用「utf8」的 MySQL 和 MariaDB 用户都应该改用「utf8mb4」，永远都不要再使用「utf8」。

#### 什么是编码？什么是 UTF-8？

我们都知道，计算机使用 0 和 1 来存储文本。比如字符「C」被存成「01000011」，那么计算机在显示这个字符时需要经过两个步骤：

1. 计算机读取「01000011」，得到数字67(也就是「01000011」的十进制形式)，
2. 计算机在Unicode字符集中查找 67，找到了「C」。

同样的：

1. 我的电脑将「C」映射成Unicode字符集中的 67。
2. 我的电脑将67编码成「01000011」，并发送给 Web 服务器。

几乎所有的网络应用都使用了 Unicode 字符集，因为没有理由使用其他字符集。

Unicode 字符集包含了上百万个字符。最简单的编码是 UTF-32，每个字符使用 32 位。这样做最简单，但问题是，这样太浪费空间了。

UTF-8 可以节省空间，在 UTF-8 中，字符「C」只需要 8 位，一些不常用的字符，比如「」需要 32 位。其他的字符可能使用 16 位或 24 位。一篇类似本文这样的文章，如果使用 UTF-8 编码，占用的空间只有 UTF-32 的四分之一左右。

MySQL 的「utf8」字符集与其他程序不兼容，它所谓的字符集，可能真的是一坨……