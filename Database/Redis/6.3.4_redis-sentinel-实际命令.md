# 快速教程

假设三个实例在端口5000、5001、5002上。也假设在6379上有一个主节点Redis实例，6380上有一个从节点redis实例:

三个Sentinel配置文件应该看起来像下面这样,另外的两个配置文件也是相同的，但是使用5001,5002作为端口：

```
# 主节点(端口为6379的主节点redis实例)集群称为mymaster，它定义了主节点和它的从节点。
# 每个主节点集群有一个不同的名称，Sentinel能同时监控不同的主节点和从节点的集合。
# quorum被设置为2。
port 5000
sentinel monitor mymaster 127.0.0.1 6379 2
# down-after-milliseconds的值是5000毫秒，就是5秒钟，所以在这个时间内一旦我们不能收到回复，主节点将发现失败。
sentinel down-after-milliseconds mymaster 5000
sentinel failover-timeout mymaster 60000
sentinel parallel-syncs mymaster 1
```

Sentinel开始启动的时候，要做的事情是检查主节点的监控是否正常：

```
redis-cli -p 5000 (通过sentinel连接redis)
127.0.0.1:5000> sentinel master mymaster
# 将提供关于从节点类似的信息
SENTINEL slaves mymaster
# 关于另外的Sentinels
SENTINEL sentinels mymaster

# 获取当前主节点的地址，Sentinel也作为一个配置提供者，提供给客户端它们想连接的主节点和从节点的集群。因为可能的故障转移和重配置，客户端不知道一个集群实例内当前的活着的主节点，所以Sentinel提供了一个API：
 SENTINEL get-master-addr-by-name mymaster
```

- num-other-sentinels 是2: 主节点Sentinel已经发现了两个其他的Sentinels。如果你检查日志，你可以看到+sentinel事件发生。
- flags是master。如果主节点挂掉了，我们可以看到s_down或者o_down标志。
- num-slaves现在是1： Sentinel发现有一个从节点。

## 故障转移测试

现在我们部署Sentinel可以被测试了。我们可以杀死主节点然后查看配置变化

redis-cli -p 6379 DEBUG sleep 30

这个命令让我们的主节点变为不可达，睡眠30秒，它基本上模拟了主节点挂掉的一些原因。

>如果你检查Sentinel的日志，你应该能看到许多动作，每个Sentinel发现了主节点挂掉了并有一个+sdown事件，这个事件稍候升级到+odown，意味着大多数Sentinel已经同意了主节点是不可达的。Sentinels开始投票一个Sentinel开始并尝试故障转移

## 故障转移开始

如果你重新询问mymaster的当前主节点的地址，这次我们会得到一个不同的回复：

```
SENTINEL get-master-addr-by-name mymaster
1) "127.0.0.1"
2) "6380"
```