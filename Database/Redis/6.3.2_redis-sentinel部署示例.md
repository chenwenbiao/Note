## Sentinel部署示例

* 主节点称为M1，M2，M3，…，Mn。
* 从节点称为R1，R2，R3，…，Rn。
* Sentinels称为S1，S2，S3，…，Sn。
* 客户端称为C1，C2，C3，…，Cn。

>注意永远不要设置只有两个Sentinels，因为开始一个故障转移，Sentinels总是需要和大多数Sentinels交流。所以请至少部署三个Sentinels

示例2：三个box的基本设置

这是一个非常简单的设置，拥有更加安全的优点。它是基于三个boxes的，每个box运行一个Redis进程和Sentinel进程。

       +----+

       | M1 |

       | S1 |

       +----+

          |

+----+    |    +----+

| R2 |----+----| R3 |

| S2 |         | S3 |

+----+         +----+



Configuration: quorum = 2

如果M1挂掉，S2和S3将认同这次失败，并且能授权开始一次故障转移，这样使客户端可以继续使用。

在每一个Sentinel设置中，Redis是异步复制的，总是有丢失一些写入数据的危险，因为当一个从节点被提升为主节点的时候一个写入确认还没有到达。然而在上面的设置中，还有一种更加危险的情况，由于客户端和一个老的主节点在一个网络分区中，就像下面这样：



         +----+

         | M1 |

         | S1 | <- C1 (writes will be lost)

         +----+

            |

            /

            /

+------+    |    +----+

| [M2] |----+----| R3 |

| S2   |         | S3 |

+------+         +----+

在这种情况下，网络分区把旧的主节点[M1]给孤立了，所以从节点R2被提升为主节点。然而，像客户端C1，和旧的主节点在同一个网络分区中，或许继续像旧的主节点写入数据。当分区治愈，这些数据将永久丢失，这个旧得主节点将会被重新配置，作为新的主节点下的一个从节点，并丢弃它自己的数据。

可以使用下面的Redis复制特性减轻这个问题，如果一个主节点发现它不再能够把它的写入请求发送给指定数量的从节点，它就停止接受写入请求。

min-slaves-to-write 1
min-slaves-max-lag 10

当上面的配置应用于一个Redis实例。Redis发现它不能写入至少一个1从节点，作为主节点的Reids将会停止接受写入请求。由于复制是异步，不能写入也意味着从节点也是断开的，或者超过了指定的max-lag秒数没有发送异步回应。

在上面的示例中，使用这个配置的旧的主节点M1，在10秒过后就不可用了。当分区治愈，Sentinel配置将会统一为新的，客户端C1将获取到一个有效的配置并且继续。

然而天下没有免费的午餐，在这种改进下，如果两个从节点挂掉了，主节点将会停止接收写入请求，这就是一个权衡。

示例3：Sentinel在客户端所在的box中

有时候，我们只有两个Redis box是可用的，一个给主节点，一个给从节点。在那种情况下，示例2中的配置是不可行的，我们可以采取下面的方法，Sentinels被放置在客户端所在的地方：

            +----+         +----+

            | M1 |----+----| R1 |

            | S1 |    |    | S2 |

            +----+    |    +----+

                      |

         +------------+------------+

         |            |            |

         |            |            |

      +----+        +----+      +----+

      | C1 |        | C2 |      | C3 |

      | S1 |        | S2 |      | S3 |

      +----+        +----+      +----+



      Configuration: quorum = 2

在这种设置下，Sentinels的视角和客户端是 一样的：如果大部分的客户端认为一个主节点是可用的，它就是可用的。这里的C1，C2，C3是一般的客户端， 并不意味着C1是连接到Redis的单个客户端，它更像一个应用服务器，一个Redis app，或者类似的东西。

如果M1和S1所在的box挂掉了，故障转移将会进行，但是很明显的看到不同的网络分区将导致不同的行为。比如说，如果客户端和Redis服务断开连接，Sentinel将不会被设置，因为Redis的主节点和从节点都是不可用的。

注意如果C3和M1在一个分区，我们有了一个和示例2中描述的类似的问题，不同的是，这里我们没有办法打破对称，因为只有一个主节点和从节点，所以主节点不会停止接收请求。

所以这是一个有效的设置，但是实例2中的设置更有优势，比如Redis高可用系统，Redis运行在同一个box中，更容易被管理，并且可以限制在小部分的分区中主节点接收写入请求的时间。

示例4：Sentinel 客户端 这一边少于三个客户端

示例3描述的设置中，如果客户端这一边的box少于不够三个，这个 设置就不能使用。在这种情况下，我们需要借助混合设置，像下面这样：



            +----+         +----+

            | M1 |----+----| R1 |

            | S1 |    |    | S2 |

            +----+    |    +----+

                      |

               +------+-----+

               |            |  

               |            |

            +----+        +----+

            | C1 |        | C2 |

            | S3 |        | S4 |

            +----+        +----+



      Configuration: quorum = 3

这和示例3中的设置非常相似，但是这里我们在可用的四个box中运行了四个Sentinel。如果主节点M1变成不可用节点，其他三个Sentinel将执行故障转移。

理论上，当移除S2和S4正在运行的box，这个设置可以工作，把quorum设置为2。然而，在应用层没有高可用的系统，想在Redis这一边得到高可用是不太可能的。

Sentinel，Docker,NAT 和可能的问题

Docker使用被称为端口映射的技术：与一个程序认为他使用的端口相比，运行在Docker容器里面的程序可能被暴露在不同的端口上。为了运行多个容器在相同的服务器上同时使用同一个端口，这是非常有用的。

Docker不是唯一会发生这件事情的软件系统，也有其他的网络地址转换设置导致端口是被重映射，并且有时候没有端口，只有IP地址。

端口和地址重映射在两个方面制造了与Sentinel有关的问题：

Sentinel的自动发现服务将停止工作，因为它使基于每个Sentinel 往它监听的端口和IP地址广播hello消息来实现的。但是Sentinels没有办法来理解端口和IP地址被重映射了，所以他会宣布它和其他的Sentinels的连接是不正常的。

在一个主节点的INFO输出中，从节点 被列出来也是类似的方式：主节点检查远端对等的TCP连接来发现地址，在握手过程中，从节点自己广告他的端口，然而由于相同的原因，端口或许是错误的。

因为Sentinels自动发现从节点使用主节点的INFO输出信息，发现的从节点是不可达的，并且Sentinel将永远不会开始故障转移，因为从系统的观点来看，没有好的从节点，所以目前没有方式监控使用Docker部署的主节点和从节点实例，除非你通知Docker以1:1映射端口。

对于第一个问题，万一你想使用Docker运行一堆Sentinel实例，你可以使用下面的两个Sentinel配置，为了强迫Sentinel宣布一个指定的端口和IP：

sentinel announce-ip <ip>
sentinel announce-port <port>
注意，Docker可以运行host networking模式。这就不会有问题因为端口不会被重新映射。
