## 事务

### 概念

Redis事务是一组命令的集合。事务同命令一样都是Redis的最小执行单位，一个事务中的命令要么都执行，要么都不执行.使用事务的场景就是希望一串命令在执行的时候不被中断以及不被其他命令插入.

```shell
# 事务的原理: 将属于一个事务的命令发送给Redis，然后再让Redis依次执行这些命令:

# MULTI告诉Redis:“下面我发给你的命令属于同一个事务，你先不要执行，而是把它们暂时存起来:
NUMTI

# 实现关注和被关注操作
SADD "user:1:following" 2

# 返回QUEUED表示这两条命令已经进入等待执行的事务队列中了
SADD "user:2:followers" 1

# Redis将等待执行的事务队列中的所有命令,按照发送顺序依次执行,返回值是这些命令的返回值组成的列表
EXEC
```

>Redis保证一个事务中的所有命令要么都执行，要么都不执行。如果在发送EXEC命令前客户端断线了，则Redis会清空事务队列，事务中的所有命令都不会执行。而一旦客户端发送了EXEC命令，所有的命令就都会被执行，即使此后客户端断线也没关系，因为Redis中已经记录了所有要执行的命令

### 事务的错误处理

#### 语法错误

只要有一个命令有语法错误，执行EXEC命令后Redis就会直接返回错误，连语法正确的命令也不会执行.`语法错误完全可以在开发时找出并解决.`

>注意：Redis 2.6.5之前的版本会忽略有语法错误的命令，然后执行事务中其他语法正确的命令

```shell
redis＞MULTI
OK
redis＞SET key value
QUEUED
redis＞SET key
(error)ERR wrong number of arguments for 'set' command
redis＞ ERRORCOMMAND key
(error) ERR unknown command 'ERRORCOMMAND'
redis＞ EXEC
(error) EXECABORT Transaction discarded because of previous errors.
```

#### 运行错误

在命令执行时出现的错误，比如使用散列类型的命令操作集合类型的键，这种错误在实际执行之前Redis是无法发现的，所以这样的命令是会被Redis接受并执行的。如果事务里的一条命令出现了运行错误，事务里其他的命令依然会继续。

>如果能够很好地规划数据库（保证键名规范等）的使用，是不会出现如命令与数据类型不匹配这样的运行错误的

```shell
redis＞MULTI
OK
redis＞SET key 1
QUEUED
redis＞SADD key 2
QUEUED
redis＞SET key 3
QUEUED
redis＞EXEC
1) OK
2) (error) ERR Operation against a key holding the wrong kind of value
3) OK
redis＞GET key
"3"
```

>Redis的事务没有关系数据库事务提供的回滚（rollback） 功能。为此开发者必须在事务执行出错后自己收拾剩下的摊子（将数据库复原回事务执行前的状态等）。
不过由于Redis不支持回滚功能，也使得Redis在事务上可以保持简洁和快速

### WATCH命令介绍(可以防止竞态条件)

>WATCH命令可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就`都不会执行`。监控一直持续到EXEC命令（事务中的命令是在EXEC之后才执行的）.

有些情况下需要先获得一条命令的返回值，然后再根据这个值执行下一条命令.

```shell
# 执行WATCH命令后、事务执行前修改了key的值
SET key 1
WATCH key
SET key 2

MULTI
# 不会执行修改key的操作
SET key 3
# 不会执行修改key2的操作
set key2 a
# 事务中的命令SET key 3没有执行，EXEC命令返回空结果nil
EXEC

GET key
GET key2
```

#### WATCH命令如何来防止竞态条件?

```shell
# 伪代码
# EXEC命令返回值是多行字符串类型，所以代码中使用result[0]来获得其中第一个结果
def incr( key)
WATCH key
value=GET key
if not value
value=0
value= value+1
MULTI
SET key, value
result=EXEC
return result[0]
```

>提示:由于WATCH命令的作用只是当被监控的键值被修改后阻止另一个事务(`另一个同时想要修改被监控键的事务`)的执行，而不能限制其他客户端一直不修改这一键值(其他客户端虽然这次修改被阻止了，但是下一次还要修改)，所以被阻止的事务的客户端`需要在EXEC执行失败后重新执行整个函数.`

执行EXEC命令后会取消对所有键的监控，如果不想执行事务中的命令也可以使用UNWATCH命令来取消监控

```shell
# 作用是仅当字段存在时才赋值。为了避免竞态条件我们使用事务来完成这一功能：
def hsetxx( key, field, value)
WATCH key
isFieldExists = HEXISTS key, field
# 代码中会判断要赋值的字段是否存在，如果字段不存在的话就不执行事务中的命令，
# 但需要使用UNWATCH命令来保证下一个事务的执行不会受到影响.(如果不unwatch的话，多个客户端同时修改会有问题)
if isFieldExists is 1
MULTI
HSET key, field, value
EXEC
else
UNWATCH
return isFieldExists
```