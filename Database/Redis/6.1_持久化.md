## Redis 持久化

### Redis持久化概念

>Redis的强劲性能很大程度上是由于其将所有数据都存储在了内存中，为了使Redis在重启之后仍能保证在内存中的数据不丢失，需要将数据从内存中以某种形式同步到硬盘中，这一过程就是持久化。

### Redis持久化方式

>Redis支持两种方式的持久化，一种是RDB方式，一种是AOF方式。可以单独使用其中一种或将二者结合使用。

1. `RDB持久化`可以在`指定的时间间隔`内生成数据集的时间点快照（point-in-time snapshot）
2. `AOF持久化记录服务器执行的所有写操作命令`，并`在服务器启动时，通过重新执行这些命令来还原数据集`。AOF文件中的命令全部以 Redis协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小.
3. Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， `当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。`
4. 你甚至可以关闭持久化功能，让数据只在服务器运行时存在。

## RDB和AOF持久化方式的异同

>了解 RDB 持久化和 AOF 持久化之间的异同是非常重要的.

### RDB方式特点以及优缺点介绍(Redis默认采用的持久化方式)

* RDB方式的持久化是通过快照（snapshotting）完成的，`当符合一定条件时Redis会自动将内存中的所有数据进行快照并存储在硬盘上`。
* 进行快照的条件可以由用户在配置文件中自定义，`由两个参数构成：时间和改动的键的个数`。当在指定的时间内被更改的键的个数大于指定的数值时就会进行快照
* Redis默认会将快照文件存储在当前目录的dump.rdb文件中，可以通过配置dir和dbfilename两个参数分别指定快照文件的存储路径和文件名。

>`RDB是Redis默认采用的持久化方式，在配置文件中已经预置了3个条件：`

```
# save参数指定了快照条件，可以存在多个条件，条件之间是“或”的关系。
# save900 1的意思是在15分钟（900秒钟）内有至少一个键被更改则进行快照。
# 如果想要禁用自动快照，只需要将所有的save参数删除即可。
save 900 1
save 300 10
save 60 10000
```

>理清Redis实现快照的过程对我们了解快照文件的特性有很大的帮助。快照的过程如下:

1. Redis使用fork函数复制一份当前进程（父进程）的副本（子进程）；
2. 父进程继续接收并处理客户端发来的命令，而子进程开始将内存中的数据写入硬盘中的临时文件
3. 当子进程写入完所有数据后会用该临时文件替换旧的RDB文件，至此一次快照操作完成

>在执行fork的时候操作系统（类Unix操作系统）会使用写时复制（copy-on-write）策略，
即fork函数发生的一刻父子进程共享同一内存数据，当父进程要更改其中某片数据时（如执行一个写命令），
`操作系统会将该片数据复制一份以保证子进程的数据不受影响`，所以新的RDB文件存储的是执行fork一刻的内存数据。也就是说
在没有改变某片数据的时候，父子进程是共享同一内存数据的。当要改变某一分片的数据的时候，会把要改变的数据复制一份，然后
父进程做更新数据的操作，子进程使用的是未更改之前的数据(执行fork一刻的数据)。

通过上述过程可以发现Redis在进行快照的过程中不会修改RDB文件，`只有快照结束后才会将旧的文件替换成新的，也就是说任何时候RDB文件都是完整的。这使得我们可以通过定时备份RDB文件来实现Redis数据库备份。`RDB文件是经过压缩（可以配置rdbcompression参数以禁用压缩节省CPU占用）的二进制格式，所以占用的空间会小于内存中的数据大小，更加利于传输。

#### RDB手动快照

除了自动快照，还可以手动发送SAVE或BGSAVE(即background save)命令让Redis执行快照，两个命令的区别在于，前者是由主进程进行快照操作，会阻塞住其他请求，后者会通过fork子进程进行快照操作。

### 从rdb文件恢复数据

Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。根据数据量大小与结构和服务器性能不同，这个时间也不同。通常将一个记录一千万个字符串类型键、大小为1GB的快照文件载入到内存中需要花费20～30秒钟。

### RDB使用场景考量

通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据。这就需要开发者根据具体的应用场合，通过组合设置自动快照条件的方式来将可能发生的数据损失控制在能够接受的范围。如果数据很重要以至于无法承受任何损失，则可以考虑使用AOF方式进行持久化。

>RDB的优点:

1. RDB是一种表示某个即时点的Redis数据的紧凑文件。RDB文件适合用于备份。例如，你可能想要每小时归档最近24小时的RDB文件，每天保存近30天的RDB快照。`这允许你很容易的恢复不同版本的数据集以容灾。`
2. RDB非常适合于灾难恢复，作为一个紧凑的单一文件，可以被传输到远程的数据中心，或者是Amazon S3(可能得加密)。
3. RDB最大化了Redis的性能，因为Redis父进程持久化时唯一需要做的是启动(fork)一个子进程，由子进程完成所有剩余工作。父进程实例不需要执行像磁盘IO这样的操作。
4. RDB在重启保存了大数据集的实例时比AOF要快。

>RDB 的缺点

1. 当你需要在Redis停止工作(例如停电)时最小化数据丢失，RDB可能不太好。虽然可以配置不同的保存点(save point)来保存RDB文件(例如，至少5分钟和对数据集100次写之后，但是你可以有多个保存点)。然而，你通常每隔5分钟或更久创建一个RDB快照，所以一旦Redis因为任何原因没有正确关闭而停止工作，你就得做好最近几分钟数据丢失的准备了。
2. RDB需要经常调用fork()子进程来持久化到磁盘。如果数据集很大的话，fork()比较耗时，结果就是，当数据集非常大并且CPU性能不够强大的话，Redis会停止服务客户端几毫秒甚至一秒。AOF也需要fork()，但是你可以调整多久频率重写日志而不会有损(trade-off)持久性(durability)。

### AOF方式特点以及优缺点介绍

    AOF 的优点:

使用AOF会更具有可持久性(durable)：你可以有很多不同的fsync策略:

* 没有fsync
* 每秒fsync(默认的)
* 每次请求时fsync

>默认的每秒fsync策略，写性能也仍然很不错(fsync是由后台线程完成的，主线程继续努力地执行写请求)，即便损失数据，也仅仅损失一秒钟的写数据。

1. AOF日志是一个追加文件，所以不需要定位，在断电时也没有损坏问题。即使由于某种原因文件末尾是一个写到一半的命令(磁盘满或者其他原因),redis-check-aof工具也可以很轻易的修复。
2. 当AOF文件变得很大时，Redis会自动在后台进行重写。重写是绝对安全的，因为Redis继续往旧的文件中追加，使用创建当前数据集所需的最小操作集合来创建一个全新的文件，一旦第二个文件创建完毕，Redis就会切换这两个文件，并开始往新文件追加。
3. AOF文件里面包含一个接一个的操作，以易于理解和解析的格式存储。你也可以轻易的导出一个AOF文件。例如，即使你不小心错误地使用FLUSHALL命令清空一切，如果此时并没有执行重写，你仍然可以保存你的数据集，你只要停止服务器，删除最后一条命令，然后重启Redis就可以。

    AOF 的缺点:

1. 对同样的数据集，AOF文件通常要大于等价的RDB文件。
2. AOF可能比RDB慢，这取决于准确的fsync策略。通常fsync设置为每秒一次的话,性能仍然很高，如果关闭fsync，即使在很高的负载下也和RDB一样的快。不过，即使在很大的写负载情况下，RDB还是能提供能好的最大延迟保证。

>Redis AOF是通过递增地更新一个已经存在的状态，像MySQL或者MongoDB一样，而RDB快照是一次又一次地从头开始创造一切，概念上更健壮。但是，1)要注意Redis每次重写AOF时都是以当前数据集中的真实数据从头开始，相对于一直追加的AOF文件(或者一次重写读取老的AOF文件而不是读内存中的数据)对bug的免疫力更强。2)我们还没有收到一份用户在真实世界中检测到崩溃的报告。

默认情况下Redis没有开启AOF（append only file-仅附加文件）方式的持久化，可以通过appendonly参数开启：`appendonly yes`

开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof，可以通过appendfilename参数修改：`appendfilename appendonly.aof`

```shell
# AOF持久化的具体实现，假设在开启AOF持久化的情况下执行了如下4个命令
SET foo 1
SET foo 2
SET foo 3
GET foo

# Redis会将前3条命令写入AOF文件中，此时AOF文件中的内容如下:
*2
$6
SELECT
$1
0
*3
$3
set
$3
foo
$1
1
*3
$3
set
$3
foo
$1
2
*3
$3
set
$3
foo
$1
3
```

>可见AOF文件是纯文本文件，其内容正是Redis客户端向Redis发送的原始通信协议的内容，从中可见Redis确实只记录了前3条命令。然而这时有一个问题是前2条命令其实都是冗余的，因为这两条的执行结果会被第三条命令覆盖。随着执行的命令越来越多，AOF文件的大小也会越来越大，即使内存中实际的数据可能并没有多少。很自然地，我们希望Redis可以自动优化AOF文件，就上例而言，就是将前两条无用的记录删除，只保留第三条。实际上Redis也正是这样做的，每当达到一定条件时Redis就会自动重写AOF文件，这个条件可以在配置文件中设置：

```shell
# auto-aof-rewrite-percentage参数的意义是当目前的AOF文件大小超过上一次重写时的
# AOF文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时的AOF文件大小为依据。
auto-aof-rewrite-percentage 100

# auto-aof-rewrite-min-size参数限制了允许重写的最小AOF文件大小，
# 通常在AOF文件很小的情况下即使其中有很多冗余的命令我们也并不太关心。
auto-aof-rewrite-min-size 64mb
```

>除了让Redis自动执行重写外，我们还可以主动使用BGREWRITEAOF命令手动执行AOF重写。
可见冗余的命令已经被删除了。重写的过程只和内存中的数据有关，和之前的AOF文件无关，
这与RDB很相似，只不过二者的文件格式完全不同。
上例中的AOF文件重写后的内容为：

```shell
*2
$6
SELECT
$1
0
*3
$3
SET
$3
foo
$1
3
```

在启动时Redis会逐个执行AOF文件中的命令来将硬盘中的数据载入到内存中，载入的速度相较RDB会慢一些。

**aof文件从硬盘缓存写入到硬盘**

>需要注意的是虽然每次执行更改数据库内容的操作时，AOF都会将命令记录在AOF文件中，但是事实上，由于操作系统的缓存机制，数据并没有真正地写入硬盘，而是进入了系统的硬盘缓存。在默认情况下系统每30秒会执行一次同步操作，以便将硬盘缓存中的内容真正地写入硬盘，在这30秒的过程中如果系统异常退出则会导致硬盘缓存中的数据丢失。一般来讲启用AOF持久化的应用都无法容忍这样的损失，这就需要Redis在写入AOF文件后主动要求系统将缓存内容同步到硬盘中。在Redis中我们可以通过appendfsync参数设置同步的时机：

```shell
# always表示每次执行写入都会执行同步，这是最安全也是最慢的方式。
# appendfsync always

# 默认情况下Redis采用everysec 规则，即每秒执行一次同步操作。
# 一般情况下使用默认值everysec就足够了，既兼顾了性能又保证了安全。
appendfsync everysec

# no表示不主动进行同步操作，而是完全交由操作系统来做（即每30秒一次），这是最快但最不安全的方式。
# appendfsync no
```

### RDB 和 AOF ,我应该用哪一个？

一般来说,如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。
Redis允许同时开启AOF和RDB，既保证了数据安全又使得进行备份等操作十分容易。此时重新启动Redis后,Redis会使用AOF文件来恢复数据，因为AOF方式的持久化可能丢失的数据更少。 

如果你非常关心你的数据,但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。

有很多用户单独使用AOF，但是我们并不鼓励这样，因为时常进行RDB快照非常方便于数据库备份，
启动速度也较之快，还避免了AOF引擎的bug。

>注意：基于这些原因，将来我们可能会统一AOF和RDB为一种单一的持久化模型(长远计划)。