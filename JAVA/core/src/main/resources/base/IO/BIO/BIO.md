# 传统的BIO

## Server端只开启一个线程处理客户端请求

采用 **BIO 通信模型** 的服务端，通常由一个独立的` Acceptor 线程`负责监听客户端的连接。我们一般通过在服务端中，`while(true)` 循环中调用 `accept()` 方法等待接收客户端的连接的请求，一旦接收到一个连接请求，就可以建立通信套接字，在这个通信套接字上进行读写操作.
 
## "Server端只开启一个线程处理客户端请求"会有什么问题

Server端如果用一个线程去处理客户端请求，一旦接收到一个请求后(假设客户端为A)，就不能再接收其他客户端连接请求，只能等待当前连接的客户端A的操作执行完成.主要原因是`socket.accept()`、`socket.getInputStream().read()`、`socket.getOutputStream().write()` 涉及的三个主要函数都是同步阻塞的.

## "Server端只开启一个线程处理客户端请求引发的问题"如何解决?

可以通过多线程来支持多个客户端的连接。如果要让 **BIO 通信模型** 能够同时处理多个客户端请求，就必须使用多线程，也就是说在接收到客户端连接之后为每个客户端创建一个线程进行处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的 **一请求一应答通信模型** 。

## "Server端对客户端的每个请求都开一个线程处理"会有什么问题?

**我们再设想一下当客户端并发访问量增加后这种模型会出现什么问题？**

在 Java 虚拟机中，线程是宝贵的资源，线程的创建和销毁成本很高，除此之外，线程的切换成本也是很高的。尤其在 Linux 这样的操作系统中，线程本质上就是一个进程，`创建和销毁线程都是重量级的系统函数`。如果并发访问量增加会导致线程数急剧膨胀,可能会导致创建新线程失败等问题，最终导致进程宕机或者僵死，不能对外提供服务。

可以设想一下如果某一个客户端连接不做任何事情的话，就会造成不必要的线程开销。

## 怎么解决"Server端对客户端的每个请求都开一个线程处理"引发的问题?

可以通过 **线程池机制** 改善，线程池还可以让线程的创建和回收成本相对较低。使用`FixedThreadPool` 可以有效的控制了线程的最大数量，防止由于海量并发接入导致线程耗尽，保证了系统有限的资源的合理分配，实现了N(客户端请求数量):M(Server端处理客户端请求的线程数量)的模型（N 可以远远大于 M）

采用`线程池和任务队列`可以实现这种模型。当有新的客户端接入时，将客户端的 Socket 封装成一个Task（该任务实现java.lang.Runnable接口）投递到后端的线程池中进行处理，JDK 的线程池维护一个消息队列和 N 个活跃线程，对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，`它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。`

>因此避免了为每个请求都创建一个独立线程造成的线程资源耗尽问题。不过因为它的底层任然是同步阻塞的BIO模型，因此无法从根本上解决问题。再高的并发(十万/百万级别的并发)就会有问题。

![](../../pics/线程池+任务队列.png)

## BIO适用场景

在活动连接数不是特别高（小于单机1000）的情况下，这种模型(`线程池和任务队列`)是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。
