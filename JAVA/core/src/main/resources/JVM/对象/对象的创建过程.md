# 对象的创建过程

    第一步: 类加载检查: 当 JVM收到new指令时，会去运行时常量池中寻找,查看类是否被加载.
    如果没加载,则加载类的字节码.并且检查字节码是否是合法的.

    第二步: 在java堆中分配内存空间

# 对象分配内存的方式

    有2种方式: 指针碰撞 和 空闲列表
    选择那种分配方式由堆是否规整决定，而堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定
    复制算法和标记整理算法都是堆内存规整的,标记清除算法是内存相互交错的.

- 指针碰撞(使用的前提是堆内存是完全工整的):用过的内存和没用的内存各在一边,每次分配的时候只需要将指针向空闲内存一方移动一段区域即可
- 空闲列表(已经使用的内存和未使用的内存互相交错时):当堆中已经使用的内存和未使用的内存**互相交错**时，指针碰撞的方式就行不通了，这时就需要采用空闲列表的方式。虚拟机会维护一个空闲的列表，用于记录哪些内存是可以进行分配的，分配时直接从可用内存中直接分配即可.

# 对象内存分配过程的并发问题

    给对象分配内存时也会出现并发问题,jvm采用两种方式来保证线程安全:

    第一种: CAS乐观锁: 每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止

    第二种: TLAB : Thread Local Allocation Buffer,叫线程本地的分配缓存, 每个线程在堆内存中分配私有的一块内存,
    线程只需要在自己的堆空间中分配即可，由于这个内存区域是线程私有的，所以不会出现并发问题。
    可以使用 -XX:+/-UseTLAB 参数来设定 JVM 是否开启 TLAB, JVM在给线程中的对象分配内存时，首先在TLAB分配，
    当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配

# 对象中的访问定位的2种方式

    对象的访问方式由虚拟机实现而定，主流的访问方式有2种: 使用句柄 和 直接指针

1. **句柄：** 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例的具体地址
2. **直接指针：**  reference 中存储的直接就是对象的地址

---

    使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，对象被移动时,reference 本身不需要修改
    句柄的使用,方便了实例位置的改变,可以不改变引用,但是访问速度相对于指针低一些.
    
    使用直接指针访问方式最大的好处就是速度快，它节省了一次通过句柄来定位对象的时间开销

>对于我们常用的 `HotSpot` 虚拟机是通过`直接指针`来关联的。这样的好处就是：在 Java 里进行频繁的对象访问可以提升访问速度.
