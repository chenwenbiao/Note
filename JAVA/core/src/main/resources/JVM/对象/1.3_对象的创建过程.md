# 创建对象

当 `JVM` 收到一个 `new` 指令时(比如执行 new MyClass())，去常量池中寻找,查看类是否被加载.如果没加载,则加载class.

接着就是在java堆中分配内存空间，通常有两种方式：

- 指针碰撞(前提是堆内存是完全工整的):使用指针碰撞的前提是堆内存是**完全工整**的，用过的内存和没用的内存各在一边,每次分配的时候只需要将指针向空闲内存一方移动一段区域即可。
- 空闲列表(已经使用的内存和未使用的内存互相交错时):当堆中已经使用的内存和未使用的内存**互相交错**时，指针碰撞的方式就行不通了，这时就需要采用空闲列表的方式。虚拟机会维护一个空闲的列表，用于记录哪些内存是可以进行分配的，分配时直接从可用内存中直接分配即可

堆中的内存是否工整是有**垃圾收集器**来决定的，如果`带有压缩功能的垃圾收集器`就是采用指针碰撞的方式来进行内存分配的。

>对象中的访问定位:

1. 句柄池,句柄池从堆中划分,由实例地址和类型数据地址构成.
2. 指针,可直接通过指针访问到实例对象

>句柄的使用,方便了实例位置的改变,可以不改变引用,但是访问速度相对于指针低一些.

# 对象的内存分配过程的并发问题

分配内存时也会出现并发问题,这样可以在创建对象的时候使用 `CAS` 这样的乐观锁来保证。

也可以将内存分配安排在每个线程独有的空间进行，每个线程首先在堆内存中分配一小块内存，称为本地分配缓存(`TLAB : Thread Local Allocation Buffer`)

分配内存时，只需要在自己的分配缓存中分配即可，由于这个内存区域是线程私有的，所以不会出现并发问题。可以使用 `-XX:+/-UseTLAB` 参数来设定 `JVM` 是否开启 `TLAB` 。

内存分配之后需要对该对象进行设置，如对象头。

# 对象访问

一个对象被创建之后自然是为了使用，在 `Java` 中是通过栈来引用堆内存中的对象来进行操作的。

对于我们常用的 `HotSpot` 虚拟机来说，这样引用关系是通过`直接指针`来关联的。

这样的好处就是：在 Java 里进行频繁的对象访问可以提升访问速度(相对于使用句柄池来说)。

# 内存分配深入

## Eden 区分配

简单的来说对象都是在堆内存中分配的，往细一点看则是优先在 `Eden` 区分配。

这里就涉及到堆内存的划分了，为了方便垃圾回收，JVM 将堆内存分为新生代和老年代。

而新生代中又会划分为 `Eden` 区，`from Survivor、to Survivor` 区。

其中 `Eden` 和 `Survivor` 区的比例默认是 `8:1:1`，当然也支持参数调整 `-XX:SurvivorRatio=8`。

当在 `Eden` 区分配内存不足时，则会发生 `minorGC` ，由于 `Java` 对象多数是**朝生夕灭**的特性，所以 `minorGC` 通常会比较频繁，效率也比较高。

当发生 `minorGC` 时，JVM 会根据`复制算法`将存活的对象拷贝到另一个未使用的 `Survivor` 区，如果 `Survivor` 区内存不足时，则会使用分配担保策略将对象移动到老年代中。

谈到 `minorGC` 时，就不得不提到 `fullGC(majorGC)` ，这是指发生在老年代的 `GC` ，不论是效率还是速度都比 `minorGC` 慢的多，回收时还会发生 `stop the world` 使程序发生停顿，所以应当尽量避免发生 `fullGC` 。

当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。

内存的分配担保: 如果另外一块Survivor空间没有足够的空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代.

#### 1. 对象优先在 Eden 分配

大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。

#### 2. 大对象直接进入老年代

大对象是指需要连续内存空间的对象（很长的字符串以及数组）

经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。

-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。

### 3. 长期存活的对象进入老年代

为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。

-XX:MaxTenuringThreshold 用来定义年龄的阈值

### 4. 动态对象年龄判定

虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。

### 5. 空间分配担保

在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。

如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。

## 老年代分配

也有一些情况会导致对象直接在老年代分配，比如当分配一个大对象时(大的数组，很长的字符串)，由于 `Eden` 区没有足够大的连续空间来分配时，会导致提前触发一次 `GC`，所以尽量别频繁的创建大对象。

因此 `JVM` 会根据一个阈值来判断大于该阈值对象直接分配到老年代，这样可以避免在新生代频繁的发生 `GC`。

对于一些在新生代的老对象 `JVM` 也会根据某种机制移动到老年代中。

JVM 是根据记录对象年龄的方式来判断该对象是否应该移动到老年代，根据新生代的复制算法，当一个对象被移动到 `Survivor` 区之后 JVM 就给该对象的年龄记为1，每当熬过一次 `minorGC` 后对象的年龄就 +1 ，直到达到阈值(默认为15)就移动到老年代中。

> 可以使用 `-XX:MaxTenuringThreshold=15` 来配置这个阈值。
