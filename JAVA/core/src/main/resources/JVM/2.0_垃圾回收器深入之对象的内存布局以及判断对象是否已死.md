# 垃圾收集器深入

Java与C++之间有一堵由`内存动态分配和垃圾收集`技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。

Java程序员把内存控制权利交给Java虚拟机，不再需要像C/C++程序开发程序员这样为一个new 操作去写对应的delete/free操作。

GC的历史远远比Java久远，1960年诞生于MIT的Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。当Lisp还在胚胎时期时，人们就在思考GC需要完成的三件事情：

1. 哪些内存需要回收
2. 什么时候回收
3. 如何回收？

## 哪些内存需要回收

前面介绍了Java内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈三个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内不需要过多考虑回收的问题，因为方法结束或线程结束时，内存自然就跟随着回收了。

而`Java堆和方法区`则不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存，本教程后续讨论中的“内存”分配与回收也仅指这一部分内存。  

垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。

## 对象的内存布局

HotSpot(HotSpot: 热点)虚拟机中，对象在内存中存储的布局可以分为三块区域：

- 对象头（Header）
- 实例数据（Instance Data）
- 对齐填充（Padding）

### 1. 对象头

HotSpot虚拟机的对象头包括两部分信息，`第一部分`用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机中分别为32个和64个Bits，官方 称它为“Mark Word”.

![](pics/对象头.png)

`对象头的另外一部分是类型指针`，即是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

另外，如果对象是一个Java数组，那在对象头中还必 须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组对象的元数据中无法确定数组的大小。

### 2. 实例数据（Instance Data）

接下来实例数据部分是对象真正存储的有效信息，也既是我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的都需要记录下来。这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。 HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、 oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果 CompactFields参数值为true（默认为true），那子类之中较窄的变量也可能会插入到父类变量的空隙之中。

### 对齐填充

第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。对象头部分正好似8字节的倍数（1倍或者2 倍），因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。 

## 判断对象是否已死

垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象有哪些还“存活”着，哪些已经“死去”（即不可能再被任何途径使用的对象）。

>判断对象是否已死的方法包括：

- 引用计数法
- 根搜索算法

### 1、引用计数算法（Reference Counting）

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候引用计数器为0的对象就是不可能再被使用的。

这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。

```java
// 在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，
// 导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。
public class Test {

    public Object instance = null;

    public static void main(String[] args) {
        Test a = new Test();// 线程栈中的变量a引用堆中的对象，假设起名叫A,所以A的引用+1
        Test b = new Test();// 线程栈中的变量b引用堆中的对象，假设起名叫B,所以B的引用+1
        a.instance = b;// A引用B，所以B的引用+1
        b.instance = a;// B引用 A，所以A的引用+1
        a = null;// 线程栈中的变量a不再引用堆中的对象A，所以A的引用-1
        b = null;// 线程栈中的变量b不再引用堆中的对象B，所以B的引用-1
        // 此时A和B的引用都是1，都不是0，而且永远都不会变为0，因为循环引用
        doSomething();
        // a 与 b 引用的对象实例互相持有了对象的引用，
        // 因此当我们把对 a 对象与 b 对象的引用去除之后，由于两个对象还存在互相之间的引用，
        // 导致两个 Test 对象无法被回收。
    }
}
```

### 2、根搜索算法

在主流的商用程序语言中（Java和C#，甚至包括前面提到的古老的Lisp），都是使用根搜索算法（GC Roots Tracing）判定对象是否存活的。

这个算法的基本思路就是通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。

如下图所示，对象object 5、object 6虽然互相有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。 

![](pics/1455907953405030724.png) 

在Java语言里，可作为GC Roots的对象包括下面几种：

1. 虚拟机栈中的局部变量表引用的对象。
2. 方法区中类的静态变量所引用的对象
3. 方法区中的常量引用的对象。
4. 本地方法栈中JNI中的引用的对象。

