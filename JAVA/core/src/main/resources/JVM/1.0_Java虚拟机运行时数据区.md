# JVM内存划分

- 虚拟机栈(VM Stack)，或称为线程栈(也就是我们平时说的栈内存)-这块区域不用调优
- 本地方法栈(Native Method Stack)-这块区域不用调优
- 程序计数器(Program counter register)
- 方法区(Method Area)
- 堆区(Heap)-跟jvm的调优密切相关。jvm调优主要就是调优堆区。这个要深入剖析

---
    可以划分为2类，线程私有和线程共享:
    
    线程私有:虚拟机栈、本地方法栈、程序计数器。这些数据区会随着线程开始和结束而创建和销毁
    线程共享数据区:方法区、堆区。随着虚拟机启动而创建，随着虚拟机退出而销毁，并且被进程中的所有线程共享.
---

# 直接内存(堆外内存)

`直接内存并不是由 `JVM` 虚拟机所管理的一块内存区域,不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域`，但是这部分内存也被频繁地使用。而且也可能导致OutOfMemoryError异常出现。

JDK1.4中新加入的NIO类,它可以直接使用Native函数库直接分配堆外内存，然后通过在堆内存中的 `DirectByteBuffer` 对象操作的堆外内存。这样就能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。这样的高效操作也称为`零拷贝`。

既然是内存，那也得是可以被回收的。但由于堆外内存不直接受 `JVM` 管理，所以常规 `GC` 操作并不能回收堆外内存。它是借助于老年代产生的 `fullGC` 顺便进行回收。同时也可以显式调用 `System.gc()` 方法进行回收（前提是没有使用 `-XX:+DisableExplicitGC` 参数来禁止该方法）。

**值得注意的是**：虽然直接内存的分配不会受到Java堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。由于堆外内存也是内存，是由操作系统管理。如果应用有使用堆外内存则需要平衡虚拟机的堆内存和堆外内存的使用占比。避免出现堆外内存溢出。(也就是堆外内存不能用的太狠了,否则也可能抛出oom异常)
