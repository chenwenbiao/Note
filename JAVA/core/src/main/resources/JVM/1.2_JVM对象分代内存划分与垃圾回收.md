# JVM对象分代内存划分与垃圾回收

下面我们从对象分代年龄的角度对JVM内存进行划分，这与JVM的垃圾回收息息相关.

对象没有引用的时候称为垃圾，垃圾回收器就会进行垃圾回收。

有些对象会频繁的创建与销毁，例如我们在方法里面使用到局部变量，每次调用，方法里的局部变量就要经历创建与销毁的过程

而另外一些对象可能会常驻内存，例如静态成员变量。

---

    来自IBM的一组统计数据：
    
    98％的java对象，在创建之后不久就变成了非活动对象；只有2％的对象，会在长时间一直处于活动状态。
    
    如果能对这两种对象区分对待，那么会提高GC的效率。在sun jdk gc中（具体的说，是在jdk1.4之后的版本），提出了不同生命周期的GC策略。

---

>现在我们从另外一个角度对JVM的运行时内存进行划分：堆(Heap)堆和非堆(Non-heap)内存

 按照官方的说法：“Java 虚拟机具有一个堆，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。

## 一、基于对象分代年龄的内存划分

从对象分代的角度来说，JVM的内存大致分为3块：分别是Permanent Generation（简称PermGen、持久代）、New Generation(又叫Young Generation，年轻代)和Tenured Generation（又叫Old Generation，年老代）。其中Permanent Generation位于non-heap区。New和Old是Java应用的Heap区，用来存放类实例的。

>Tenured: 终身的， Survivor: 幸存者, Eden:伊甸园

![](根据对象分代年龄划分JVM内存.png)

![](Hotspot堆内存结构图.png)

Old区用于存放长寿的对象，在New区中经历了N次垃圾回收后仍然存活的对象，就会被放到Old区中；如那些与业务信息相关的对象，包括Http请求中的Session对象、Socket连接等，这类对象跟业务直接挂钩，因此生命周期比较长。

## 二、基于对象分代年龄的垃圾回收

在以上提到的任何一个空间不够用时，都会促使JVM执行垃圾回收。基于回收对象的年龄的不同，我们将垃圾回收划分为：

- Minor GC(又叫Young GC,Minor: 次要的，较小的，未成年人,年轻的)：回收新生代内存空间(Eden、From Survivor、To Survivor),因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。
- Full GC：回收新生代和老年代(Tenured Generation)、永久代PermGen内存,老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多（慢10倍以上）。

### Minor GC/Young GC触发

当新对象生成，并且在Eden申请空间失败时(空间不够)，就会触发Minor GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区，然后整理Survivor的两个区。这种方式的GC是对New区的Eden区进行，不会影响到Old区。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的Minor GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。

### Full GC触发

Full GC要对整个Heap区进行回收，包括New、Old和PermGen，所以比Minor GC要慢，因此应该尽可能减少Full GC的次数。`在对JVM性能调优的过程中，很大一部分工作就是对于Full GC的调节`。有如下原因可能导致Full GC：

1. 老年代空间不足:应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代.还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。
2. JDK 1.7以及1.7以前的永久代空间不足，在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。
3. System.gc()被显示调用:只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机自己管理内存。
4. 使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC
5. 执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。

需要注意的是，Full GC与YoungGC是无法完全区分开来的，很多情况下，Full GC是由YoungGC导致的。例如在Eden Space中的对象经历过几次垃圾回收，依然还存活，就会移动到Tenured区，而如果此时Tenured区空间不够，就会触发垃圾回收，过程如下图所示：

![](minor-gc-major-gc-full-gc.jpg)

对于Survivor区域，其实际上就是经历过几次垃圾回收依然没有被回收掉的对象(称之为幸存者)过渡到Tenured区的临时存储空间。

## 内存分配策略

### 1. 对象优先在 Eden 分配

大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。

### 2. 大对象直接进入老年代

大对象是指需要连续内存空间的对象（种很长的字符串以及数组）

经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。

-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。

### 3. 长期存活的对象进入老年代

为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。

-XX:MaxTenuringThreshold 用来定义年龄的阈值。

### 4. 动态对象年龄判定

虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。

### 5. 空间分配担保

在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。

如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。