# jmap

    最主要的一个作用就是把当前java进程的内存状态给dump下来.
    
    jmap -dump:file=xxx pid 
    (就可以堆的信息给dump到机器上了,如果想要查看这个堆信息的话,需要下载专门的工具才能查看这个堆信息,一般在线上运行的时候,可以直接先把内存信息dump下来,然后我们下载这个dump文件,然后用专门的图形化工具来分析内存专用状态到底是什么样的)

    jmap -heap pid 可以打印当前堆上的内存信息 (显示的比较人性化,可以看到具体值)

jmap(Java Memory Map)命令可以获得运行中的jvm的堆的快照，从而可以离线分析堆，以检查内存泄漏，检查一些严重影响性能的大对象的创建，检查系统中什么对象最多，各种对象所占内存的大小。

>命令语法：jmap [option] <pid>(其中pid可以通过jps命令获取)，option可选项如下： 

* -heap：打印jvm 内存整体使用情况 
* -histo[:live]：打印jvm heap的直方图。其输出信息包括类名，对象数量，对象占用大小。 
* -permstat：打印permanent generation heap情况 
* -dump:<dump-options>：dump java内存到二进制文件中。

---
    dump-options: 
    
    live       是否只dump当前存活的对象，如果不指定，将会dump所有的对象，包括待回收的对象。
    
    format=b    文件的格式
    
    file=<file>  指定文件的输出位置
---

>上述命令中的-histo和-dump都包含一个live选项，如果指定live，在统计前会进行full gc，因此不加live的堆大小要大于加live堆的大小。

```
# 1、打印jvm 内存整体使用情况
# 可以观察到New Generation（Eden Space，From Space，To Space）,tenured generation,Perm Generation的内存使用情况
jmap -heap pid  

# 2、查看类名，对象数量，对象占用大小
# 可以观察heap中所有对象的情况（heap中所有生存的对象的情况）。包括对象数量和所占空间大小。 
jmap -histo[:live] pid | more
jmap -histo:live pid | head -7
# instances列：表示当前类有多少个实例。
# bytes列：说明当前类的实例总共占用了多少个字节
# class name列：表示的就是当前类的名称，

# class name 解读：
B代表byte 
C代表char 
D代表double 
F代表float 
I代表int 
J代表long 
Z代表boolean 
前边有[代表数组，[I 就相当于int[] 
对象用[L+类名表示 


# 手工dump内存到本地文件
jmap -dump:file=heap.map pid  
```

## 下面介绍一个MAT，这个用的比较多

MAT(Memory Analyzer Tool)

MAT是一个eclipse的插件，上手起来比较快。它能够快速的分析dump文件，可以直观的看到各个对象在内存占用的量大小，以及类实例的数量，对象之间的引用关系，找出对象的GC Roots相关的信息，此外还能生成内存泄露报表，疑似泄露大对象的报表等等。
安装MAT

可以选择eclipse插件的方式安装http://download.eclipse.org/mat/1.3/update-site/
也可以选择单独MAT程序下载安装http://www.eclipse.org/mat/downloads.php

## 内存溢出时，自动保存dump文件

前面是手工导出内存dump映射文件，如果应用已经在线上运行，为了能获取应用出现内存溢出时获得heap dump文件，以便在之后分析，可以在JVM启动时指定参数：-XX:+HeapDumpOnOutOfMemoryError，JVM会在遇到OutOfMemoryError时保存一个“堆转储快照”，并将其保存在一个文件中。 文件路径通过-XX:HeapDumpPath指定。

>设置虚拟机参数为：-Xmx40m -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:\Java\dump.hprof

生成了文件之后，就可以通过MAT打开来进行分析