# 垃圾回收器

垃圾回收算法是内存回收的方法论，垃圾回收器是垃圾回收算法的具体实现

垃圾收集器也是分代的:年轻代和老年代使用的垃圾收集器是不一样的

![](../pics/Sun_HotSpot虚拟机1.7版垃圾回收器.jpg)

# 7种具体的垃圾收集器

    新生代可以使用哪些?老年代使用哪些?这个非常重要!!

- Serial收集器(新生代)
- ParNew收集器(新生代)
- Parallel Scavenge收集器(新生代)
- Serial Old收集器(老年代)
- Parallel Old收集器(老年代)
- CMS收集器(老年代)
- G1收集器(新生代和老年代)

---
    单线程: 单线程指的是垃圾收集器只使用一个线程
    多线程: 多线程使用多个线程进行垃圾回收
---

![](../pics/垃圾回收器小总结.png)

# Parallel Scavenge收集器

Parallel Scavenge收集器的关注点与其他收集器不同，CMS等收集器的关注点尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（Throughput）。

所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户程序时间 /（运行用户程序时间 + 垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。

停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验；

而高吞吐量则可以最高效率地利用CPU时间，尽快地完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。

    GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，停顿时间变短,垃圾回收变得频繁，导致吞吐量下降。

Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数及直接设置吞吐量大小的-XX:GCTimeRatio参数

    MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过设定值。
    不过大家不要异想天开地认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，
    GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，
    这也直接导致垃圾收集发生得更频繁一些，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。

GCTimeRatio参数的值应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1 /（1+19）），默认值为99，就是允许最大1%（即1 /（1+99））的垃圾收集时间。

由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称为“吞吐量优先”收集器。

    GC自适应的调节策略

除上述两个参数之外，Parallel Scavenge收集器还有一个参数-XX:+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。

如果读者对于收集器运作原理不太了解，手工优化存在困难的时候，使用Parallel Scavenge收集器配合自适应调节策略，把内存管理的调优任务交给虚拟机去完成将是一个很不错的选择。只需要把基本的内存数据设置好（如-Xmx设置最大堆），然后使用MaxGCPauseMillis参数（更关注最大停顿时间）或GCTimeRatio参数（更关注吞吐量）给虚拟机设立一个优化目标，那具体细节参数的调节工作就由虚拟机完成了。自适应调节策略也是Parallel Scavenge收集器与ParNew收集器的一个重要区别。

# CMS收集器

    由于整个过程中"耗时最长的并发标记和并发清除过程中"，收集器线程都可以与用户线程一起工作，不需要进行停顿
    
    CMS缺点: 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高,对CPU资源敏感

    现在互联网公司老年代主流的就是采用CMS,G1相对比较新的技术还没有使用.

# G1收集器（Garbage-First）
    
    G1垃圾收集器经常问.
    
    java9的默认就是G1
   
    G1 可以直接对新生代和老年代一起回收

    G1与前面的CMS收集器相比有两个显著的改进
        1. 不会产生碎片: 与CMS的“标记清除”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；
        从局部上来看是基于“复制”算法实现的。不会产生空间碎片.
        2. 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。

    G1收集器可以实现在基本不牺牲吞吐量的前提下完成低停顿的内存回收.

这是由于它能够极力地避免全区域的垃圾收集，之前的收集器进行收集的范围都是整个新生代或老年代，而G1将整个Java堆（包括新生代、老年代）划分为多个大小固定的独立区域（Region），每个Region来进行独立的垃圾回收.

G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限时间内可以尽可能高的收集效率