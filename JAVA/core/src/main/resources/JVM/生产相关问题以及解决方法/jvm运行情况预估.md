# 年轻代对象的增长速率

    可以执行jstat -gc pid 1000 10(每隔1秒执行1次命令,共执行10次),通过观察EU(Eden区的使用)来估算每秒eden大概新增多少对象,
    如果系统负载不高,可以把频率1秒换成1分钟jstat -gc pid 60000 10(每隔1分钟执行1次命令,共执行10次),甚至换成10分钟来观察
    整体情况,注意,一般系统可能有高峰期和日常期,所以需要在不同的时间分别估算不同情况下对象增长速率.
    
# Young GC的触发频率和每次耗时

    知道年轻代对象增长速率,我们可以根据eden区大小,推算出young gc大概多久触发一次,Young GC的平均耗时可以通过YGCT/YGC算出,
    根据结果我们大概能知道系统大概多久会因为Young GC的执行而卡顿多久.

# 每次Young GC后,有多少对象存活,以及多少对象进入老年代

    上面已经计算出Young GC的频率,假设是5分钟一次,那么可以执行命令jstat -gc pid 300000 10,观察每次结果eden,survivor,和老年代使用情况的变化,在每次gc后,eden区使用一般会大幅减少,survivor和老年代都有可能增长,这些增长的对象就是每次Young GC后存活的对象,同时还可以计算出每次young gc后,进入老年代大概多少对象,从而计算出老年代对象的增长速率

# full gc的触发频率和每次耗时

    知道了老年代的增长速率,就可以推算出full gc的触发频率,full gc的每次耗时可以通过FGCT/FGC计算出.

# 优化思路

    其实简单说就是一句话: 尽量让每次young gc后的存活对象小于survivor区的50%,都留存在年轻代里,尽量别让对象进入老年代,尽量减少full gc的频率,避免频繁full gc对jvm性能的影响.                