# 对象优先在 Eden 分配

对象都是在堆内存中分配的，往细一点看则是优先在 `Eden` 区分配,大多数情况下，对象在新生代 Eden 上分配

当在 `Eden` 区分配内存不足时，则会发生 `minorGC` ，由于 `Java` 对象多数是**朝生夕灭**的特性，所以 `minorGC` 通常会比较频繁，效率也比较高。

当发生 `minorGC` 时，JVM 会根据`复制算法`将存活的对象拷贝到另一个未使用的 `Survivor` 区，如果 `Survivor` 区内存不足时，则会使用分配担保策略将对象移动到老年代中。

谈到 `minorGC` 时，就不得不提到 `fullGC` ，不论是效率还是速度都比 `minorGC` 慢的多，回收时还会发生 `stop the world` 使程序发生停顿，所以应当尽量避免发生 `fullGC` 

当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有小于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。

内存的分配担保: 如果另外一块Survivor空间没有足够的空间存放minor GC存活下来的对象，这些对象将直接通过分配担保机制进入老年代.

# 对象进入老年代的情况汇总

- 满足条件的 大对象直接进入老年代
- 年龄达到阈值,进入老年代
- 动态对象年龄判定满足条件,也会进入老年了

# 大对象直接进入老年代

    如果经常创建大对象(需要连续内存空间的对象-字符串/数组),则会提前触发mimor gc,解决方法就是: 
    设置一个阈值,如果大小大于这个阈值的对象直接进入老年代.-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，
    避免在 Eden 和 Survivor 之间的大量内存复制

# 长期存活的对象进入老年代(年龄达到阈值,进入老年代)

    为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，
    年龄就增加 1 岁，增加到一定年龄则移动到老年代中。-XX:MaxTenuringThreshold 用来定义年龄的阈值

# 动态对象年龄判定

    jvm并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，
    如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，
    则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄

# 空间分配担保

在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。

如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。
