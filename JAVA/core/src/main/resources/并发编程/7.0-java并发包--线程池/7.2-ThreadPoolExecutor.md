ThreadPoolExecutor 类是JDK提供的ExecutorService接口的默认实现。提供一个可扩展的线程池实现。ExecutorService在Executor接口的基础上，添加了一些可以管理Executor自身生命周期以及任务的生命周期的方法，每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。 

ThreadPoolExecutor构造方法参数说明:

1. 如果ThreadPoolExecutor是有默认的线程工厂，如果我们不传，就使用默认的线程工厂
2. RejectedExecutionHandler：被拒绝的执行处理程序，如果我们不传，就使用默认的被拒绝的执行处理程序

## corePoolSize和maximumPoolSize

1. 当新任务在方法execute中提交时，如果运行的线程少于 corePoolSize，则创建新线程来处理请求，即使其他辅助线程是空闲的。
2. 如果运行的线程多于 corePoolSize 而少于 maximumPoolSize，则仅当队列满时才创建新线程。
3. 如果设置的 corePoolSize 和 maximumPoolSize 相同，则创建了固定大小的线程池。
4. 如果将 maximumPoolSize 设置为基本的无界值（如 Integer.MAX_VALUE），则允许池适应任意数量的并发任务。
5. 在大多数情况下，核心和最大池大小仅基于构造来设置，不过也可以使用 setCorePoolSize(int) 和 setMaximumPoolSize(int) 进行动态更改

## keepAliveTime与timeUnit

1. 如果池中当前有多于corePoolSize的线程，则这些多出的线程在空闲时间超过 keepAliveTime 时将会终止。
2. 这提供了当池处于非活动状态时减少资源消耗的方法。如果池后来变得更为活动，则可以创建新的线程。
3. 也可以使用方法setKeepAliveTime(long, java.util.concurrent.TimeUnit) 动态地更改此参数。
4. 默认情况下，保持活动策略只在有多于 corePoolSizeThreads 的线程时应用。
5. 但是只要 keepAliveTime 值非 0，allowCoreThreadTimeOut(boolean) 方法也可将此超时策略应用于核心线程

## workQueue

1. 如果运行的线程少于corePoolSize，则Executor始终首选添加新的线程,而不进行排队.
2. 如果运行的线程等于或多于corePoolSize，则Executor始终首选将请求加入队列，而不添加新的线程。 
3. 如果无法将请求加入队列，则创建新的线程，除非创建此线程超出 maximumPoolSize，在这种情况下，任务将被拒绝。 

### 排队有三种通用策略： 

1. 直接提交：工作队列默认是使用SynchronousQueue类创建实例，`它将任务直接提交给线程而不保持它们`。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes 以避免拒绝新提交的任务。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 
2. 无界队列。使用无界队列（例如使用不具有预定义容量的LinkedBlockingQueue）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，创建的线程就不会超过 corePoolSize。（因此，maximumPoolSize 的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在Web页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。 
3. 有界队列。当使用有限的 maximumPoolSizes 时，有界队列（如ArrayBlockingQueue）有助于防止资源耗尽，但是可能较难调整和控制。队列大小和最大池大小可能需要相互折衷：使用大型队列和小型池可以最大限度地降低 CPU 使用率、操作系统资源和上下文切换开销，但是可能导致人工降低吞吐量。如果任务频繁阻塞（例如，如果它们是 I/O 边界），则系统可能为超过您许可的更多线程安排时间。使用小型队列通常要求较大的池大小，CPU 使用率较高，但是可能遇到不可接受的调度开销，这样也会降低吞吐量。

### ThreadFactory

使用ThreadFactory创建新线程。如果没有另外说明，则在同一个ThreadGroup中一律使用 Executors.defaultThreadFactory() 创建线程，并且这些线程具有相同的 NORM_PRIORITY 优先级和非守护进程状态。通过提供不同的ThreadFactory，可以改变线程的名称、线程组、优先级、守护进程状态等。如果从newThread返回 null 时 ThreadFactory 未能创建线程，则执行程序将继续运行，但不能执行任何任务。

### RejectedExecutionHandler

当Executor已经关闭，并且Executor 将有限边界用于最大线程和工作队列容量，且已经饱和时，在方法execute(java.lang.Runnable)中提交的新任务将被拒绝。在以上两种情况下,execute方法都将调用其 RejectedExecutionHandler 的 RejectedExecutionHandler.rejectedExecution(java.lang.Runnable, java.util.concurrent.ThreadPoolExecutor) 方法。下面提供了四种预定义的处理程序策略： 

1. 在默认的 ThreadPoolExecutor.AbortPolicy 中，处理程序遭到拒绝将抛出运行时 RejectedExecutionException。 
2. ThreadPoolExecutor.CallerRunsPolicy中，线程调用运行该任务的execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。
3. 在ThreadPoolExecutor.DiscardPolicy中，不能执行的任务将被删除。 
4. 在ThreadPoolExecutor.DiscardOldestPolicy中，如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）。 

定义和使用其他种类的RejectedExecutionHandler 类也是可能的，但这样做需要非常小心，尤其是当策略仅用于特定容量或排队策略时

>示例org.java.core.base.concurrent.chapter7.ThreadPoolExecutorTest.java

### ThreadFactory演示

线程池中的线程默认都是根据ThreadFactory创建，如果在构建ThreadPoolExecutor的时候，没有指定ThreadFactory，默认就会使用Executors.defaultThreadFactory()获取ThreadFactory实例。ThreadFactory只定义了一个抽象方法，用于返回新的线程：

```java
public interface ThreadFactory {
    Thread newThread(Runnable r);
    }
```