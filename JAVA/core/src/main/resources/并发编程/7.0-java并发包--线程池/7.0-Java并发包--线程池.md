## 为什么引入线程池

![](https://ws2.sinaimg.cn/large/006tKfTcgy1ftpxf3x1epj30la03s0tl.jpg)

谈到线程池就会想到池化技术，核心的思想是把宝贵的资源放到一个池中；每次使用都从里面获取，用完之后又放回池子供其他人使用.

在之前的案例中，我们总是通过启动一个新的线程来执行新的任务。对于一些小的应用来说，这是OK的，但是对于一些大型的应用来说，这是不太合适的。例如对于一个高并发的web服务器，如果每一个HTTP请求，我们都使用一个新的线程来处理，那么内存中必然会存在大量的线程，线程的上下文切换以及线程的创建与销毁，都会消耗大量的资源.

因此我们最好将`线程的管理、创建、销毁等操作`与`线程需要执行的任务隔离开来`。具体来说，我们希望有一个类，专门用于管理一批Thread对象，而线程对象的运行时代码(Runnable或者Callable接口的实现类)则另外定义，当需要执行这些任务时，将任务提交给这个类，这个类会安排空闲的线程来运行这个任务。从而避免线程频繁的创建与销毁，以及大量的线程的上下文切换造成的资源损耗.

## Executor的含义

>java并发包的设计者也考虑到了上述问题，并将这种起到线程管理作用的类称之为Executor。与Executor相关的主要有3个接口:

![](Executor相关接口.png)

1. `java.util.concurrent.Executor`是顶级接口，其只定义了一个`void execute(Runnable command)`方法，用于接受可以执行的任务
2. `public interface ExecutorService extends Executor {}`接口在Executor的基础上添加了一些生命周期方法，例如shutdown等.
3. `public interface ScheduledExecutorService extends ExecutorService {}`则进行了一些功能性的扩展，添加了可以在指定的时间、或者周期性的运行某个任务的方法抽象.

通常情况下，线程池的实现，都包含了一个线程池(thread pool)和一个任务队列(task queue)。我们向executors中提交任务(Runnable或者Callable接口的实现类)，executors会将提交的任务放入任务队列中。然后会从thread pool中选择一个空闲的线程来处理队列中的任务，如果线程池中的所有线程都在处理其他任务，那么等到某个线程处理完自己的任务空闲下来的时候，再将任务队列中的任务交由其处理。下图展示了线程池的工作原理：

![线程池的工作原理](线程池的工作原理.png)

从图可以看到，我们提交的任务都会放到executor内部维护的一个任务队列(Task Queue)中，executor会从thread pool中取出线程，来运行执行任务队列中的任务。而thread pool中的线程对象，是通过一个线程工厂(Thread Factory)对象来创建的。使用Thread Factory的原因是因为，通常一个线程池中的所有Thread对象的作用都是相同的，因此我们可能会希望按照某种相同的规则来创建线程，例如给线程池中的所有线程名字都起一个公共的前缀。

事实上，JDK自带的executors的实现，都利用到了我们上述提到的概念：线程工厂(Thread Factory)，线程池(Thread pool)以及任务队列(Task Queue)， 如：ThreadPoolExecutor、ScheduledThreadPoolExecutor、java.util.concurrent.ForkJoinPool。

![JDK中的executors的相关类](JDK中的executors的相关类.png)

>其中对于Fork/Join框架是JDK1.7中引入的利用多处理器特性的并发编程框架

## 线程池的状态

```java
// 线程池中所定义的状态，这些状态都和线程的执行密切相关:
public class ThreadPoolExecutor extends AbstractExecutorService {
    private static final int RUNNING    = -1 << COUNT_BITS;
    private static final int SHUTDOWN   =  0 << COUNT_BITS;
    private static final int STOP       =  1 << COUNT_BITS;
    private static final int TIDYING    =  2 << COUNT_BITS;
    private static final int TERMINATED =  3 << COUNT_BITS;
    
    public void execute(Runnable command) {
        if (command == null)
                 throw new NullPointerException();
            // 获取当前线程池的状态
             int c = ctl.get();
             // 当前线程数量小于 coreSize 时创建一个新的线程运行
             if (workerCountOf(c) < corePoolSize) {
                 if (addWorker(command, true))
                     return;
                 c = ctl.get();
             }
             if (isRunning(c) && workQueue.offer(command)) {// 如果当前线程处于运行状态，并且写入阻塞队列成功
                 int recheck = ctl.get();
                 // 双重检查，再次获取线程池状态；如果线程池状态变了（非运行状态）就需
                 // 要从阻塞队列移除任务，并尝试判断线程是否全部执行完毕。同时执行拒绝策略
                 if (! isRunning(recheck) && remove(command))
                     reject(command);
                 else if (workerCountOf(recheck) == 0) // 如果当前线程池为空就新创建一个线程并执行
                     addWorker(null, false);
             }
             else if (!addWorker(command, false))//如果在第三步的判断为非运行状态，尝试新建线程，如果失败则执行拒绝策略
                 reject(command);
         }
}
```

- `RUNNING` 自然是运行状态，指可以接受任务执行队列里的任务
- `SHUTDOWN` 指调用了 `shutdown()` 方法，不再接受新任务了，但是队列里的任务得执行完毕。
- `STOP` 指调用了 `shutdownNow()` 方法，不再接受新任务，同时抛弃阻塞队列里的所有任务,并中断所有正在执行任务。
- `TIDYING` 所有任务都执行完毕，在调用 `shutdown()/shutdownNow()` 中都会尝试更新为这个状态。
- `TERMINATED` 终止状态，当执行 `terminated()` 后会更新为这个状态。

![](ThreadPoolExecutor_State.jpg)

## 线程池到底应该配置多少线程

>通常我们是需要根据任务的性质来确定的，当然这些都是经验值，最好的方式还是根据实际情况测试得出最佳配置:

- IO 密集型任务：由于线程并不是一直在运行，所以可以尽可能的多配置线程，比如 CPU 个数 * 2 
- CPU 密集型任务（大量复杂的运算）应当分配较少的线程，比如 CPU 个数相当的大小。

## 优雅的关闭线程池

有运行任务自然也有关闭任务，从上文提到的 5 个状态就能看出如何来关闭线程池。
其实无非就是两个方法 `shutdown()/shutdownNow()`。但他们有着重要的区别：

- `shutdown()` 执行后停止接受新任务，会把队列的任务执行完毕。
- `shutdownNow()` 也是停止接受新任务，但会中断所有的任务，将线程池状态变为 stop。

> 两个方法都会中断线程，用户可自行判断是否需要响应中断。

`shutdownNow()` 要更简单粗暴，可以根据实际场景选择不同的方法。我通常是按照以下方式关闭线程池的：

```java
    long start = System.currentTimeMillis();
    for (int i = 0; i <= 5; i++) {
        pool.execute(new Job());
    }

    pool.shutdown();

    while (!pool.awaitTermination(1, TimeUnit.SECONDS)) {
        LOGGER.info("线程还在执行。。。");
    }
    long end = System.currentTimeMillis();
    LOGGER.info("一共处理了【{}】", (end - start));
```

`pool.awaitTermination(1, TimeUnit.SECONDS)` 会每隔一秒钟检查一次是否执行完毕（状态为 `TERMINATED`），当从 while 循环退出时就表明线程池已经完全终止了。

