## AbstractQueuedSynchronizer(AQS-抽象队列同步器)概述

1. AbstractQueuedSynchronizer是JDK 1.5引入的，构建同步组件的基础，通常简称为AQS。
2. AQS是java并发包中最核心的一个类，没有之一。可以说没有弄懂AQS，就没有真正的掌握java并发包，AQS是在LockSupport和Unsafe类的基础上实现的
3. 同步组件内部都是使用了AQS来构建的，AQS是同步组件构建的基础,AQS的使用方式主要是通过继承，`注意不是直接让同步组件继承`，而是在同步组件内部定义一个静态内部类继承AQS，并覆写其特定的方法，来实现具有不同功能的同步组件

>本节主要是学习使用AQS构建我们自己的同步组件，然后以后介绍JDK的同步组件.

## 同步组件基础知识介绍

**同步组件分类：**

### 独占式同步组件(又称独占锁）

在任一时刻只能有一个线程获取到锁，可以执行。其他线程被阻塞，进去等待队列。类似于synchronized关键字的作用

### 共享式同步组件（又称共享锁）

共享锁允许多个线程同时运行，通常情况下，共享锁内部维护了`若干个执行许可(后文简称许可)`，每个线程执行的时候获取一个许可，运行结束的时候释放许可。当一个线程请求执行时，如果共享锁已经没有许可，那么该线程进入等待队列。

### 独占式和共享式同步组件的异同
>注：可以认为独占式同步组件是共享式同步组件的一个特例，其只有1个许可。从这个角度理解的话 ，我们认为不论是独占式同步组件还是共享式同步组件，都应该提供获取许可与释放许可的功能。

- 获取许可：如果线程能够成功获取许可，则拥有执行的权利，可用许可总数量减1，如果没有获取到许可，线程被阻塞，并被加入等待队列。

- 释放许可：拥有执行许可的线程运行完成后，释放许可，可用许可数量为+1。如果等待队列中存在被阻塞的线程，要`负责唤醒等待的线程`。

>可以看到，在获取许可和释放许可的过程中，都有两个非常重要的基本内容要维护：

1. 可用许可的数量
2. 等待队列

>队列同步器AbstractQueuedSynchronizer作为构建同步组件的基础框架。支持独占式地获取同步状态，也可以支持共享式的获取同步状态，这样就可以方便实现不同类型的同步组件`例如：ReentryLock、ReentryReadWriteLock、和CountDownLatch等都是在AQS的基础上编写的`

不管是独占式同步组件还是共享式同步组件，使用的过程`本质上都是获取许可与释放许可`。
而获取与释放许可过程中最关键的又是对于许可数量的维护以及等待队列的维护。而AQS对这二者都提供了支持.

#### 等待队列的支持

>通过内置的FIFO队列来完成资源获取线程的排队工作，队列的节点是基于内部静态类Node实现`需要注意的是，AQS对于等待队列的支持是完全的，也就是对开发者完全屏蔽了被阻塞线程的入队与出队操作的实现细节；
而对可有许可数量(也就是对state变量)的维护只是提供了部分支持，需要开发者覆写特定的方法才能正常工作。

- 对于等待队列的支持是完全的含义：

AQS是基于模板方法设计的。可以做的是帮助我们在调用模板方法的时候，自动帮我们维护线程的等待队列。
被阻塞的线程会被封装到一个Node对象中，加入队列。被阻塞的线程执行结束之后，从队列中移除这个Node。
AQS中维护的两个变量分别表示线程等待队列的头和尾：

```java
private transient volatile Node head;
private transient volatile Node tail;
```

因为等待队列是AQS维护的，所以并没有方法提供可以直接对队列进行修改。目前情况下，
我们只需要知道AQS是通过这两个变量完成一个队列的维护即可。

- 对于state变量支持是部分的含义：

state变量的定义如下：

```java
private volatile int state;
```

对于许可数量的维护(也就是对于state变量的维护)，必须由开发人员自己来实现。
例如对于一个独占式同步组件，可能我们会希望state的最大值为1，而对于一个共享式同步组件，
我们会希望state变量的最大值是大于1的其他正整数。有时我们可能一次只获取一个许可，有时可能又会一次获取多个许可。

>作为一个基础框架，AQS是无法知道我们想要如何操作。因此不像对于等待队列的维护，
AQS提供了一些方法，可以让我们修改state变量，如下所示：

```java
protected final int getState() {
    return state;
}
protected final void setState(int newState) {
    state = newState;
}
protected final boolean compareAndSetState(int expect, int update) {
    // See below for intrinsics setup to support this
    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
}
```

- 如何保证state变量的维护与等待队列的一致性？

因为获取许可与释放许可的过程中，会同时涉及state变量的维护和等待队列的维护。
为了减少操作的复杂性， AQS是基于模板设计模式实现的，通过对模板方法的调用，可以保证对state变量和等待队列维护的一致性。

#### AQS(AbstractQueuedSynchronizer)提供的模板方法列表

方法名称                    描述
```java
// 独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，
// 否则，将会进入同步队列等待，该方法将会调用重写的tryAcquire(int arg)方法
void acquire(int arg)

// 与tryAcquire(int arg)相同，但是该方法响应中断，当前线程未获取到同步状态而进
// 入同步队列中，如果当前线程被中断，则该方法会抛出InterruptedException
void acquireInterruptibly(int arg)

// 在acquireInterruptibly(int arg)基础上增加了超时限制，如果当前线程在超时实现内没
// 有获取到同步状态，那么将会返回false，如果获取到了就返回true
boolean tryAcquireNanos(int arg, long nanosTimeout)

// 独占式释放同步状态，该方法会在释放同步状态后，将同步队列中第一个节点包含的线程唤醒
boolean release(int arg)

// 共享式的获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，
// 与独占式获取的主要区别是在同一时刻可以有多个线程获取到同步状态。
void acquireShared(int arg) 

// 与void acquireInterruptibly(int arg)相同，该方法响应中断
void acquireSharedInterruptibly(int arg)

// 在acquireSharedInterruptibly(int arg)的基础上增加了超时限制。
boolean tryAcquireSharedNanos(int arg, long nanosTimeout)   

// 共享式释放同步状态
boolean releaseShared(int arg)

// 获取等待在同步队列上的线程集合。
Collection<Thread> getQueuedThreads()
```

>同步器提供的模板方法基本上分为3类：

1. 独占式获取与释放同步状态
2. 共享式获取与释放同步状态
3. 查询同步队列中的线程等待情况

#### AQS中定义了8个模板方法，这8个模板方法与需要开发者覆写的方法的对应关系

>对应4个需要开发者覆写的方法：

##### 组件类型:`独占式同步组件`

```java
// AQS的模板方法:
void acquire(int arg)
void acquireInterruptibly(int arg)
boolean tryAcquireNanos(int arg, long nanosTimeout)

// 以上3个方法对应需要覆写的方法:
boolean tryAcquire(int arg)
```

```java
// AQS的模板方法:
boolean tryAcquireNanos(int arg, long nanosTimeout)

// 需要覆写的方法:
boolean tryRelease(int arg)
```

##### 组件类型:`共享式同步组件`

```java
// AQS的模板方法:
void acquireShared(int arg)
void acquireSharedInterruptibly(int arg)
boolean tryAcquireSharedNanos(int arg, long nanosTimeout)
// 以上3个方法，需要覆写的方法:
int tryAcquireShared(int arg)


// AQS模板方法：
boolean tryReleaseShared(int arg)

// 需要覆写的方法
boolean tryReleaseShared(int arg)
```

>此外，还需要一个isHeldExclusively()方法需要覆写，不过其没有对应的模板方法。通常情况下，
我们实现的同步组件要不就是独占式，要不就是共享式，但是也有例外，例如ReadWriteLock同时实现了独占式与共享式。

* 因此当我们需要实现一个独占式同步组件时，只需要覆写AQS的tryAcquire和tryRelease即可
* 实现一个共享式同步组件的,只需要实现tryAcquireShared和tryReleaseShared即可
* isHeldExclusively()是可选的。默认情况下，需要覆写的方法的实现都是抛出一个UnsupportedOperationException。

### 如何使用AQS构建我们自己的同步组件

只有掌握了的工作原理才能更加深入的理解并发包中的其他并发组件。
下面通过一个独占锁的示例来深入了解一下同步器的工作原理。

顾名思义，独占锁就是同一时刻只能有一个线程获取到锁，而其他获取锁的线程只能处于同步队列中等待，只有获取锁的线程释放了锁，后继的线程才能够获取锁。

>案例:org.java.core.base.concurrent.chapter5.MutexImpl.java