# Java 多线程三大核心

Java内存模型是围绕并发过程中如何处理`原子性`、`可见性`、`有序性`这三个特征来建立的。

## 原子性(Atomicity)

原子性：`即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。`

在Java中，`对基本数据类型的变量的读取`和`赋值`操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。

```java
x = 10; //语句1,
y = x; //语句2
x++; //语句3
x = x + 1; //语句4

// 其实只有语句1是原子性操作，其他三个语句都不是原子性操作。
```

1. 语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会`直接将数值10写入到工作内存中`
2. 语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。
3. x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。

>所以上面4个语句只有语句1的操作具备原子性。也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。需要注意的是，如有一段代码中有多个原子操作，但是不同的原子操作整合在一起，这段代码可能就不是原子操作了。

>在java中，可以通过synchronized或者Lock，来保证语句执行的原子性。
如果是基础类的自增操作可以使用 `AtomicInteger` 这样的原子类来实现(其本质是利用了 `CPU` 级别的 的 `CAS` 指令来完成的)。

其中用的最多的方法就是: `incrementAndGet()` 以原子的方式自增。

```java
public final long incrementAndGet() {
        for (;;) {
            long current = get();
            long next = current + 1;
            if (compareAndSet(current, next))
                return next;
        }
    }
```

首先是获得当前的值，然后自增 +1。接着则是最核心的 `compareAndSet() ` 来进行原子更新。

```java
public final boolean compareAndSet(long expect, long update) {
        return unsafe.compareAndSwapLong(this, valueOffset, expect, update);
    }
```

其逻辑就是判断当前的值是否被更新过，是否等于 `current`，如果等于就说明没有更新过然后将当前的值更新为 `next`，如果不等于则返回`false` 进入循环，直到更新成功为止。

还有其中的 `get()` 方法也很关键，返回的是当前的值，当前值用了 `volatile` 关键词修饰，保证了内存可见性。

```java
 private volatile int value;
```

## 可见性(Visibility)(涉及到硬件内存模型)

>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

由于 `CPU` 直接从主内存中读取数据的效率不高，所以都会对应的 `CPU` 高速缓存，先将主内存中的数据读取到缓存中，线程修改数据之后首先更新到缓存，之后才会更新到主内存。如果此时还没有将数据更新到主内存其他的线程此时来读取就是修改之前的数据。

`volatile` 关键字就是用于保证内存可见性，当线程A更新了 volatile 修饰的变量时，它会立即刷新到主存，并且将其余线程高速缓存中该变量的值清空，导致其余线程只能去主内存读取最新值。

使用 `volatile` 关键词修饰的变量每次读取都会得到最新的数据，不管哪个线程对这个变量的修改都会立即刷新到主内存。

`synchronized`和加锁也能能保证可见性，实现原理就是在释放锁之前其余线程是访问不到这个共享变量的。但是和 `volatile` 相比开销较大。

## 有序性(Ordering)

在Java中，一个线程中的代码总是串行执行的。如果同时存在多个线程，在没有采取同步措施的情况下，我们是无法保证线程的先后执行顺序的，线程可以并行的执行。反之，如果我们采取了同步措施，例如多个线程竞争同一个锁，那么只有获取到锁的线程才能执行，也就是说，这种情况下，即使存在多个线程，也不会同时执行，必须是一个线程执行完成后，下一个抢到锁的线程才能执行...

>synchronized关键字、加锁可以保证支`原子性、有序性和可见性` 

>volatile关键字只保证`可见性和有序性`，不保证原子性。  

