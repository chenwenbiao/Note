Java内存模型是围绕并发过程中如何处理`原子性`、`可见性`、`有序性`这三个特征来建立的。

### 原子性(Atomicity)

原子性：`即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。`

在Java中，`对基本数据类型的变量的读取`和`赋值`操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。

```java
x = 10; //语句1,
y = x; //语句2
x++; //语句3
x = x + 1; //语句4

// 其实只有语句1是原子性操作，其他三个语句都不是原子性操作。
```

1. 语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会`直接将数值10写入到工作内存中`
2. 语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。
3. x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。

>所以上面4个语句只有语句1的操作具备原子性。也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。需要注意的是，如有一段代码中有多个原子操作，但是不同的原子操作整合在一起，这段代码可能就不是原子操作了。

>在java中，可以通过synchronized关键字和Lock对象，来保证语句执行的原子性。

### 可见性(Visibility)(涉及到硬件内存模型)

>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。

在Java中，synchronized关键字、Lock对象和将介绍的volatile关键字都可以实现共享变量的可见性。

### 有序性(Ordering)

在Java中，一个线程中的代码总是串行执行的。如果同时存在多个线程，在没有采取同步措施的情况下，我们是无法保证线程的先后执行顺序的，线程可以并行的执行。反之，如果我们采取了同步措施，例如多个线程竞争同一个锁，那么只有获取到锁的线程才能执行，也就是说，这种情况下，即使存在多个线程，也不会同时执行，必须是一个线程执行完成后，下一个抢到锁的线程才能执行...

>在Java中，synchronized关键字、Lock对象以及volatile关键字都可以保证多个线程执行时的有序性。

>synchronized关键字、Lock对象同时支持原子性、有序性和可见性 

>volatile关键字只支持可见性和有序性，并不保证原子性。  

