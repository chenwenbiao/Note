## volatile关键字是如何保证可见性的

在单CPU的情况下，是不存在可见性问题的，如果是多CPU，可见性问题就会暴露出来。

线程中运行的代码最终都是交给CPU执行，而代码执行时所需使用到的数据来自于内存(或者称之为主存)。但是CPU是不会直接操作内存的，每个CPU都会有自己的缓存，操作缓存的速度比操作主存更快。

因此当某个线程需要修改一个数据时，事实上步骤是如下的：

1. 将主存中的数据加载到缓存中
2. CPU对缓存中的数据进行修改
3. 将修改后的缓存中的值刷新到内存中

多个线程操作同一个变量的情况，则可以用下图表示:

![可见性](./可见性.png)

1. 线程1、线程2、线程3操作的是主存中的同一个变量，并且分别交由CPU1、CPU2、CPU3处理。
2. 3个CPU分别将主存中变量加载到缓存中
3. 各自将修改后的缓存中的值刷新到主存中

>问题就出现在第二步，因为每个CPU操作的是各自的缓存，所以不同的CPU之间是无法感知其他CPU对这个变量的修改的，最终就可能导致结果与我们的预期不符。

而使用了volatile关键字之后，情况就有所不同，volatile关键字有两层语义：

1. 立即将缓存中数据写会到内存中
2. 其他处理器通过嗅探总线上传播过来了数据监测自己缓存的值是不是过期了，如果过期了，就会对应的缓存中的数据置为无效。而当处理器对这个数据进行修改时，会重新从内存中把数据读取到缓存中进行处理。

>在这种情况下，不同的CPU之间就可以感知其他CPU对变量的修改，并重新从内存中加载更新后的值，因此可以解决可见性问题。

## volatile关键字可见性的实际使用场景--状态变量标记

>示例:org.java.core.base.concurrent.chapter4.VolatileDemo.java