每个进程至少有一个线程，作为程序的入口，通常情况下这个线程我们称之为主线程,在Java中，程序的入口是main方法(主线程的main方法).因此main方法实际上就是运行在主线程中的。

主线程作为程序的入口，因此我们如果需要创建自己的线程，那么必须在主线程中进行创建.

我们创建了线程对象之后，其仅仅就是Java中的对象而已，只有调用了其start()方法，其才能成为一个真正意义上运行的线程。

>示例:org.java.core.base.concurrent.chapter1.MainThreadDemo.java

## java程序启动至少会启动几个线程

一个Java程序启动`至少启动几个线程`？这是一个很常见的面试题。也就是每当使用java命令执行一个类时，实际上会启动一个jvm，每一个jvm是操作系统中启动的一个进程，java本身具备垃圾回收机制，所以每个java运行时至少启动2个线程，一个main线程，另一个是垃圾回收线程。

>示例:org.java.core.base.concurrent.chapter1.ThreadNumDemo.java

## 什么是当前线程

当前线程是不断的在变化的，因为CPU会一会执行这个线程，一会又去执行另外一个线程。因此当前线程并不是固定的。如果获取当前线程的信息？

>在Java中我们可以通过Thread的静态方法currentThread()获取当前线程的信息

>示例:org.java.core.base.concurrent.chapter1.CurrentThreadDemo

## 多线程的优点

* 资源利用率更好
* 程序设计在`某些情况下`更简单(多数时候更复杂)
* 程序响应更快

>示例:org.java.core.base.concurrent.chapter1.Resource

### 资源利用率更好

>总的说来，CPU能够在等待IO的时候做一些其他的事情。这个不一定就是磁盘IO。它也可以是网络的IO，或者用户输入。通常情况下，网络和磁盘的IO比CPU和内存的IO慢的多。

### 程序设计更简单(读取然后处理文件为示例)

在单线程应用程序中，如果你想编写程序手动处理上面所提到的读取和处理的顺序，你必须记录每个文件读取和处理的状态。相反，你可以启动两个线程，每个线程 处理一个文件的读取和操作。`线程会在等待磁盘读取文件的过程中被阻塞。在等待的时候，其他的线程能够使用CPU去处理已经读取完的文件。`其结果就是，`磁盘 总是在繁忙地读取不同的文件到内存中。这会带来磁盘和CPU利用率的提升`。而且每个线程只需要记录一个文件，因此这种方式也很容易编程实现。

### 程序响应更快

如果是单线程的服务器应用，它在某一个端口监听进来的请求。当一个请求到来时，它去处理这个请求，然后再返回去监听。如果一个请求需要占用大量的时间来处理，在这段时间内新的客户端就无法发送请求给服务端。只有服务器在监听的时候，请求才能被接收。另一种设计是，`监听线程把请求传递给工作者线程(worker thread)，然后立刻返回去监听`。而`工作者线程则能够处理这个请求并发送一个回复给客户端`.

## 多线程的代价

在使用多线程时能多来的好处比所付出的代价大的时候，才使用多线程。如果存在疑问，应该尝试测量一下应用程序的性能和响应能力，而不只是猜测。

在多线程访问共享数据的时候，这部分代码需要特别的注意。线程之间的交互往往非常复杂。不正确的线程同步产生的错误非常难以被发现.

### 上下文切换的开销

当CPU从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针 等，最后才开始执行。这种切换称为“上下文切换”(“context switch”)。CPU会在一个上下文中执行一个线程，然后切换到另外一个上下文中执行另外一个线程。

>如果你使用的是Linux操作系统，你可以通过vmstat命令查看当前操作系统每秒的上下文切换次数:命令"vmstat 1 10"的含义是：每个1秒统计一次，统计10次后结束。其中cs那一列表示的就是上下文切换次数，cs是context switch的简写。可以看到目前操作系统系统上每秒上下文切换次数大致都在400-600之间(注意：第一次统计是不准的，而且这个统计是操作系统层面的)

### 增加资源消耗

类似于每个进程启动后，操作系统都要给其分配一定的内存类似，每一个线程启动后，进程也要给线程分配一定的内存，让其来保存自己的私有数据。JVM划分给`每个线程的内存区域称之为线程栈内存`。默认情况下，`栈内存的大小1M`。也就是说，`你每多启动一个线程，至少要多消耗1M的内存资源`。

我们可以尝试编写一个程序，让它创建100个线程，这些线程什么事情都不做，只是在等待，然后看看这个程序在运行的时候占用了多少内存。

## Linux操作系统对线程数的限制

