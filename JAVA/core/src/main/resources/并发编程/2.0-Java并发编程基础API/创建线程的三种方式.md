# 创建线程的三种方式

1. 写一个类继承Thread类,重写run方法.
2. 写一个类,实现Runnable接口，把这个类的实例传给Thread.
3. 写一个类,实现Callable接口，这种方式是在JDK1.5中的java并发包中引入的

Thread类也实现了Runable接口

# 创建线程与创建线程运行时代码的区别

一个很常见的错误是，将`创建线程运行时代码`和`创建线程`混为一谈。在这里先给出一个结论：
创建线程的方式只有一种，就是创建Thread对象的实例，创建线程运行时代码就是以上提到的三种方式。

对于Runnable和Callable接口，如果我们实现它们，主要就是为了`实现接口中定义的方法`，`以便线程执行时回调`，而实现的方法中的具体内容，就是我们所说的`线程运行时代码`。对于Thread，其本身是一个线程对象，不过由于其也实现了Runable接口，因此其本身是将创建线程对象和线程运行时代码合为一体了。

### 实现Callable接口

Callable接口与Runnable接口类似，其定义了一个call方法，不同的是，其可以返回运行的结果:

```java
// 泛型参数V就是返回值的类型。Callable接口需要与线程池结合使用，
// 因此后文介绍到线程池的时候再进行讲解。
public interface Callable<V> {
    V call() throws Exception;
}
```

### 创建子类还是实现Runnable接口？

我个人更倾向于实现Runnable接口这种方法,因为Java中有一个`线程池`的概念。所谓`线程池，可以理解为有一堆线程对象已经创建好了`，那么其`缺的就是线程运行时代码`,所以我们只需要提供了运行时代码就好了，因此实现Runable接口可能是更好的一种方式。
另一个原因是，java不支持多继承，只支持单继承，但是可以实现多个接口。

### 常见错误：调用run()方法而非start()方法

```java
// run()方法并非是由刚创建的新线程所执行的，而是被创建新线程的当前线程所执行了。想要让创建的新线程执行run()方法，必须调用新线程的start方法。
Thread newThread = new Thread(MyRunnable());
newThread.run();  //should be start();
```

尽管启动线程的顺序是有序的，但是执行的顺序并非是有序的,Jvm和操作系统一起决定了线程的执行顺序，他和线程的启动顺序并非一定是一致的。(线程是抢占式的抢占cpu执行)

## 线程的名字

当创建一个线程的时候，如果我们不给线程明确的起一个名字的话，JVM默认会给其指定一个默认的名字。

获取当前正在执行的线程的名称有两种方式：

1. 如果运行时代码是直接覆盖Thread类的run方法编写的，可以通过this.getName()的方式获取线程的名字；
2. 如果只是实现了Runable接口，可以通过Thread.currentThread().getName()的方式获取。

## Thread对象run方法与start()方法的区别

1. start()方法用于启动线程,然后JVM会回调线程的运行时代码(run方法代码)
2. run()方法用于执行线程的运行时代码

当我们new出一个Thread对象的时候，其仅仅只是Java中的一个对象而已。只有当我们调用了start方法的时候，其才会真正的成为一个运行的线程，也只有当线程启动后，JVM才会给线程分配相应的资源，例如栈内存空间(线程占用空间的名称)

### 覆盖了Thread对象的run方法，同时传入一个Runnable的实现类(实现了其run方法)，会执行哪个?

```java
// 看一下Thread类Runnable方法的实现:
// 其中target就是Runable对象，默认的run方法的逻辑是，如果传递了Runnable的实现类，就运行Runnable的run方法。

/* What will be run. */
private Runnable target;
....
@Override
public void run() {
    if (target != null) {
        target.run();
    }
}
// 由于我们覆写了这段代码，所以以上这段逻辑根本就不存在了，运行run方法时，实际上运行的是我们覆写后的方法中的内容，所以才输出了以上的打印结果。
```

不过二者并非不能共存，这要看我们对Thread类run方法是如何覆写的，最简单的，我们覆写的代码和run方法和Thread类中的方法完全一样，那么最终Runable接口还是会执行。或者在我们自己的run方法中执行super.run();

最后提一嘴，Thread对象实现了Runnable接口(实现了run方法)，而构造方法中又可以接受一个Runnable接口的实现类(也实现了run方法)，称之为target，在执行的时候，如果target存在，就执行target的run方法。这实际上是装饰者设计模式(又称包装设计模式)；