## 线程休眠

如果我们想在线程运行的时候，让其暂停一会，可以调用线程sleep方法，sleep方法的作用是让线程进行休眠,`意思是线程暂停执行`。在执行的休眠时间内，`该线程是不会请求CPU进行执行(也就是不会抢占cpu)`，因此其他线程可以获得更多的运行机会。

暂停是有实际的作用的，例如我们想检查远程服务器的运行状态，为了可以一直进行检查，我们可能会将检查服务器运行状况的代码放在一个`死循环`中。但是`频繁的发送请求可能又会给服务器造成压力`，因此我们可能是`希望每隔几秒中去检查一次`，这实际上就是一个`简易定时器`的作用(在Java中，定时器有一个专门的类叫做Timer)。

注意sleep方法抛出了一个InterruptedException异常。这个异常是`在线程还在休眠的时候，如果其他的线程中断(interrupt)了这个线程的执行抛出的`。中断的作用是，如果一个线程在运行期，`我们不想其继续运行下去了，就可以给其发送一个信号`，让其停止运行。注意中断和休眠的区别，`中断是让线程停止运行`，而休眠只是`暂停运行`，等到休眠时间过后，可以继续执行。

>示例:org.java.core.base.concurrent.chapter2.SleepDemo.java

## 线程的中断

1. 中断(interrupt)表示一个线程应该停止当前所做的事而去另外一件事。
2. 通常`中断是一个线程给另外一个线程发送中断信号`，程序员自行决定如如何进行响应，也就是说收到中断信号后，接下来该做什么。
3. 通常情况下，线程收到中断信号后，采取的操作都是停止运行。

>示例org.java.core.base.concurrent.chapter2.InterruptDemo

### 在运行时代码中没有调用了可以抛出InterruptedException的方法

如果在运行时代码中没有调用可以抛出中断异常的方法(例如Thread.sleep(1000);)，那么我们必须频繁的调用Thread类的静态方法interrupted()来判断是否收到一个中断信号。

### 中断状态标记

中断机制的实现是通过`一个标记中断状态(interrupt status)实现的`。我们通过`调用某个线程对象的interrupt方法来设置这个标记`。当一个线程通过`Thread的类的静态方法interrupted判断到自己被中断后，立即会将这个状态清空`。在其他的线程中，我们可以通过调用`某个线程对象的isInterrupted方法判断这个线程是否被中断，但是不会中断状态清空。`

按照惯例，当一个方法接受到中断信号时，应该以抛出InterruptedException的方式退出执行。
`注意，这种方式很重要，在后文我们将要提供的线程池中，其停止线程池时，就通过发送中断信号。而我们提交给线程池运行的Runnable或者Callable任务代码中，必须能响应中断，否则线程池可能会无法停止。`

## Thread类的join方法

Thread类有一个join方法，其作用是：在A线程中调用了另外一个线程对象B的join方法时，那么A线程必须等待B线程执行完才能继续往下执行。

Thread类型还定义了其他两个可以设置等待时间的join方法：

1. java.lang.Thread#join(long millis, int nanos)
2. java.lang.Thread#join(long millis)

>这个两个方法都是在等待了指定的时间后，如果另外一个线程还没执行完，就不管了，继续往下执行。

### join方法的实际作用

考虑某个网页上需要展示给用户看的数据存在两个不同的数据库里面。假设从A库查询需要5秒，从B库查询需要2秒。如果我们在一个线程中运行，那么总共就需要7秒。但是如果我们使用了以上的方式，使用2个线程分别去查，先执行完的等待后执行完的，也就是说只需要2秒就查询完成的那个任务等待需要5秒的那个任务，那么总共我们只需要5秒就可以查询到所有的数据，将其返回给用户。

## 线程的优先级

Java中Thread对象有一个`优先级`的概念，`优先级被划分10个级别`，创建线程的时候，`如果没有指定优先级，默认是5`。`主线程的优先级也是5`。优先级高的线程会比优先级低的线程获得更多的运行机会。

Thread类定义了3个整形常量MAX_PRIORITY、NORM_PRIORITY、MIN_PRIORITY分别用于表示支持的最高优先级，正常优先级和最低优先级。同时提供了一个getPriority()方法来获取当前线程优先级。

>示例:org.java.core.base.concurrent.chapter2.PriorityDemo.java

从结果中我们好像看到优先级高的线程P10好像并没有比优先级低的线程P1在执行的时候有什么优势。这是因为线程的执行是抢占式的，优先级高的线程只是理论上会更优先的获取执行的机会，但并不意味着一定优先执行。

事情真的是这样简单吗？

事实上，并不是所有的操作系统都支持优先级的设置，有些操作系统会直接忽略优先级的设置。`因此在实际开发中，尽量不要去设置一个线程运行时的优先级，因为结果可能不是你想要的那样。`

>提示：可以通过jps+jstack工具查看线程运行时的优先级。

首先通过jps命令查看当前操作系统中正在运行的java进程。

```shell
// 注意在windows上也有相应的exe可以运行
[root@work]# jps -l
21204 PriorityDemo2
```

21204是进程的编号，你的可能与我不一样，接着使用`jstack 21204`查看对应进程的线程信息，输出的内容可能会有很多，最好将其导入到一个文件中，我们需要通过搜索关键字"P1"和"P10"找到我们关心的部分。

需要注意的是，不同的操作系统，不同的JVM版本上导出的内容可能是不一样的。

```
其中prio，表示的是JVM设置的优先级,os_prio表示的是对应的操作系统线程的优先级(前面我们提到过，JVM线程和操作系统线程是一一对应的)。

可以看到在windows操作系统上，线程优先级好像是有作用的，P1和P10线程对应的操作系统优先级是不一样的。但是对于CentOS 6.5，可以看到对应的线程优先级都是0，事实上说明，线程的优先级设置被忽略了。 
```
