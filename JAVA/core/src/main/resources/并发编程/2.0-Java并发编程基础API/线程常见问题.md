# 创建Thread子类还是实现Runnable接口

>更倾向于实现Runnable接口这种方法
    
    原因1: 因为Java中有线程池。线程池就是有一堆Thread对象已经创建好了，那么缺的就是线程运行时代码
    所以我们只需要提供了运行时代码就好了，因此实现Runable接口可能是更好的一种方式
    
    原因2: 另一个原因是，java不支持多继承，只支持单继承，但是可以实现多个接口。

# 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？

    这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！

    new一个Thread，线程对象进入了NEW状态,这个线程对象仅仅只是Java中的一个对象而已.
    调用这个线程对象的start()方法，其才会真正的成为一个的线程,这个时候会进入了RUNNABLE状态，
    当分配到时间片后就可以开始运行了
     
    start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作.
    而直接执行run()方法，会把run方法当成一个mian线程下的普通方法去执行，并不会在某个线程中执行它

# sleep()方法和wait()方法简单对比

- 两者最主要的区别在于：**sleep方法没有释放锁，而wait方法释放了锁** 。 
- wait通常被用于线程间交互/通信，sleep通常被用于暂停执行
- 可以在任意地方调用sleep方法,但是wait()方法必须在同步代码块中被调用

# 覆盖了Thread对象的run方法，同时传入一个Runnable的实现类(实现了其run方法)，会执行哪个?

```java
private Runnable target;
// 由于我们覆写了这段代码，所以这段代码逻辑根本就不存在了，start()之后,运行的是我们覆写的run方法的内容
// 不过二者并非不能共存，这要看我们对Thread类run方法是如何覆写的，最简单的，
// 我们覆写的代码和run方法和Thread类中的方法完全一样，那么最终Runable接口还是会执行。
// 或者在我们自己的run方法中执行super.run();
@Override
public void run() {
    if (target != null) {
        target.run();
    }
}
```
