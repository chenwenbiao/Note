## 有序性

在Java中，一个线程中的代码总是串行执行的。如果同时存在多个线程，在没有采取同步措施的情况下，我们是无法保证线程的先后执行顺序的，线程可以并行的执行。反之，如果我们采取了同步措施，例如多个线程竞争同一个锁，那么只有获取到锁的线程才能执行，也就是说，这种情况下，即使存在多个线程，也不会同时执行，必须是一个线程执行完成后，下一个抢到锁的线程才能执行...

# 有序性

volatile可以保证可见性,不能保证原子性，可以保证有序性

还可以防止 `JVM` 进行指令重排优化。

举一个伪代码:

```java
int a=10 ;//1
int b=20 ;//2
int c= a+b ;//3
```

一段特别简单的代码，理想情况下它的执行顺序是：`1>2>3`。但有可能经过 JVM 优化之后的执行顺序变为了 `2>1>3`。

可以发现不管 JVM 怎么优化，前提都是保证`单线程`(这里是重点，是保证单线程最终结果不变，而不能保证多线程最终结果不变)中最终结果不变的情况下进行的。可能这里还看不出有什么问题，那看下一段伪代码:

```java
private static Map<String,String> value ;
private static volatile boolean flag = fasle ;

//以下方法发生在线程 A 中 初始化 Map
public void initMap(){
	//耗时操作
	value = getMapValue() ;//1
	flag = true ;//2
}

//发生在线程 B中 等到 Map 初始化成功进行其他操作
public void doSomeThing(){
	while(!flag){
		sleep() ;
	}
	//dosomething
	doSomeThing(value);
}
```

这里就能看出问题了，当 `flag` 没有被 `volatile` 修饰时，`JVM` 对 1 和 2 进行重排，导致 `value` 都还没有被初始化就有可能被线程 B 使用了。`所以加上 volatile之后可以防止这样的重排优化，保证业务的正确性。`(不加volatile,多线程中可能会出现数据不一致的问题)

## 指令重排的的应用

一个经典的使用场景就是`双重懒加载的单例模式`了:

```java
public class Singleton {

    private static volatile Singleton singleton;

    private Singleton() {}

    public static Singleton getInstance() {
        if (singleton == null) {
            // 多个线程有可能都等在这里，这个时候singleton有可能
            // 还是null，所以加上了volatile关键字，让每个线程及时知道singleton是否应被初始化了，
            // 所以内部又加了一层判断是否为null的if判断
            synchronized (Singleton.class) { // 这里再一次证明了volatile只能保证可见性，不能保证原子性.
                if (singleton == null) {
                    // 防止指令重排
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

这里的 `volatile` 关键字主要是为了防止指令重排。 

如果不用 ，`singleton = new Singleton();`，这段代码其实是分为三步：
- 分配内存空间。(1)
- 初始化对象。(2)
- 将 `singleton` 对象指向分配的内存地址。(3)

加上 `volatile` 是为了让以上的三步操作顺序执行，反之有可能第二步在第三步之前被执行就有可能某个线程拿到的单例对象是还没有初始化的，以致于使用的时候报错。