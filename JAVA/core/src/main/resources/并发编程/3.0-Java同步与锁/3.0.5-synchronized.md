# synchronized原理

    在多线程环境下调用Synchronized代码块，有可能需要线程上下文切换，因此可以说Synchronized是在Java语言中一个重量级操作
    
    synchronized代码块中的代码变成原子操作，只有等到同步代码块中的代码在执行完成的时候，CPU才会进行线程的上下文切换.(synchronized是悲观锁,在操作同步资源之前需要给同步资源先加锁)

    synchronized来做同步处理时，锁的获取和释放都是隐式的.

![](../pics/synchronized概述.png)

![](../pics/synchronized反编译01.png)

![](../pics/synchronized反编译02.png)

![](../pics/Monitor.png)

    当一个monitor被某一个线程持有后，这个线程就会持有这个monitor所对应的对象的的锁.
    
# 对象的内存结构

![](../pics/对象的内存结构.png)

![](../pics/对象头MarkWord.png)

![](../pics/对象头MarkWord代码实现-cpp.png)

# synchronized4种锁状态 

Java并发编程这个领域中synchronized关键字一直都是元老级的角色，以前会称它为 **“重量级锁”** 。但是在1.6之后进行了优化,主要包括为了减少获得锁和释放锁带来的性能消耗而引入的 **偏向锁** 和 **轻量级锁**.这四种锁是指synchronized锁的状态.

在线程冲突较少的情况下，可以获得和CAS类似的性能；而线程冲突严重的情况下，性能远高于CAS    

    synchronized不会一上来就是重量级锁,而是会逐步的从无锁变为重量级锁,有一个锁升级过程.

![](../pics/锁的升级过程01.png)

    偏向锁通过对比Mark Word中的线程id解决加锁问题，避免执行多次CAS操作(只有1次)。
    
    而轻量级锁是通过用CAS操作(多次)和自旋,来避免线程阻塞和唤醒而影响性能
    
    重量级锁是将除了拥有锁的线程以外的线程都阻塞。

![](../pics/synchronized锁状态的适用场景.png)

# 无锁

对象初始化后,是一个无锁的状态.

# 偏向锁

![](../pics/对象头MarkWord.png)

    在访问同步代码块的时候,会检查对象头mark word中,的锁标记位,
    如果为01(看上图),就去判断是不是偏向锁,如果不是偏向锁,使用 CAS 将线程 ID 更新到锁对象的 Mark Word 中，如果更新成功则获得偏向锁.
    并且之后每次进入这个对象锁相关的同步块时都不需要再次获取锁了,只需要看mark word中的线程id是不是当前线程即可.

![](../pics/锁的升级过程02.png)

    偏向锁适用于同一个线程反复的进入同一代码块的场景.(这种场景几乎不存在),同一线程执行同步资源时自动获取锁,
    其目标就是同一个线程执行同步代码块时能够提高性能,降低获取锁的代价.

    引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，
    因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可
    
    如果业务场景是: 锁总是由同一线程多次获得，不存在多线程竞争，就会启用偏向锁. 
    
>偏向锁在JDK 6及以后的JVM里是默认启用的。偏向锁可以提高带有同步却没有竞争的程序性能，但如果程序中大多数锁都存在竞争时，那偏向锁就起不到太大作用。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态.

# 轻量级锁

![](../pics/锁的升级过程03.png)

>偏向锁遇到其他线程尝试竞争偏向锁时，其他t2线程会等到安全点（在这个时间点上没有字节码正在执行,这个时候拥有锁的线程t1不一定执行完同步代码块了）,然后jvm会暂停拥有偏向锁的线程t1

>然后t2会判断t1是否已经释放了锁,则t2会把线程id写入mark word,t2此时拥有偏向锁.

>如果此时t1如果没有释放锁,此时就会升级为轻量级锁(通过cas更新mark Word的锁标志位设置为00以及Lock Record),t2就会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能,如果t2自旋超过一定的次数,或者又有第三个线程,轻量级锁升级为重量级锁.

    轻量级锁适用于线程交替执行的场景(注意,不是高并发场景,是交替执行),如果锁竞争激烈，轻量锁就不但有互斥的开销，还有 CAS 的开销，这时比重量锁更慢

# 重量级锁

    重量级锁(性能相对于低)适用于高并发的场景.没有获取资源的线程被阻塞(放在管程队列中等待被唤醒),等待被唤醒(涉及上下文切换)
    
    如果是重量级锁,涉及到从用户态到内核态的转换,系统开销比较大.(系统会分成用户态和内核态,为了保证安全,所以划分)

    如果你的项目天然是海量级的访问,可以根据实际情况关闭锁的升级优化,因为这会涉及大量偏向锁的撤销,偏向锁的升级等,这会造成锁的升级步骤有些多余.因为会造成额外的操作,还不如直接一上来就是重量级锁.
    
    如果你的项目不是一上来就是高并发场景,建议把锁的升级过程开启来.
