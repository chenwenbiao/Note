## wait()、notify()、notifyAll()与线程通信方式总结

### 通过wait()、notify()、notifyAll()进行线程通信

线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。例如，线程B可以等待线程A的一个信号，这个信号会通知线程B数据已经准备好了。

Java有一个内建的等待机制来`允许线程在等待信号的时候变为非运行状态`。java.lang.Object 类定义了三个方法，`wait()、notify()和notifyAll()`来实现这个等待机制

一个线程一旦调用了任意对象的wait()方法，就会变为非运行状态，直到另一个线程调用了同一个对象的notify()方法。
`为了调用 wait()或者notify()，线程必须先获得那个对象的锁。也就是说，线程必须在同步块里调用wait()或者notify()。`

```java
public class MonitorObject{
}
 
public class MyWaitNotify{
 
  MonitorObject myMonitorObject = new MonitorObject();
 
  public void doWait(){
    synchronized(myMonitorObject){
      try{
        myMonitorObject.wait();
      } catch(InterruptedException e){...}
    }
  }
 
  public void doNotify(){
    synchronized(myMonitorObject){
      myMonitorObject.notify();
    }
  }
}
```

当一个线程调用一个对象的notify()方法，正在等待该对象的所有线 程中将有一个线程被唤醒并允许执行(校注：这个将被唤醒的线程是随机的，不可以指定唤醒哪个线程),同时也提供了一个notifyAll()方法来唤醒正 在等待一个给定对象的所有线程。

如你所见，不管是等待线程还是唤醒线程都在同步块里调用wait()和notify()。这是强制性的！一个线程如果没有持有对象锁，将不能调用 wait()，notify()或者notifyAll()。否则，会抛出IllegalMonitorStateException异常。

（校注：JVM是这么实现的，当你调用wait时候它首先要检查下当前线程是否是锁的拥有者，不是则抛出IllegalMonitorStateExcept）

但是，这怎么可能？等待线程在同步块里面执行的时候，不是一直持有监视器对象（myMonitorObject）的锁吗？等待线程不能阻塞唤醒线程进入doNotify()的同步块吗？答案是：的确不能。
一旦线程调用了wait()方法，它就释放了所持有的监视器对象上的锁。这将允许其他线程也可以调用 wait()或者notify()。

一旦一个线程被唤醒，不能立刻就退出wait()的方法调用(也就是不能立刻继续接着wait()方法后执行，而是要再次获得锁才可以，因为这个线程还在同步代码块里.)，直到调用notify()的线程退出了它自己的同步块。换句话说：被唤醒的线程必须重新获得 监视器对象的锁，才可以退出wait()的方法调用，因为wait方法调用运行在同步块里面。如果多个线程被notifyAll()唤醒，那么在同一时刻 将只有一个线程可以退出wait()方法，因为每个线程在退出wait()前必须获得监视器对象的锁。

### 其他的线程通信方式

* 通过共享对象通信
* 忙等待

#### 通过共享对象通信

线程间发送信号的一个简单方式是在共享对象的变量里设置信号值。线程A在一个同步块里设置boolean型成员变量 hasDataToProcess为true，线程B也在同步块里读取hasDataToProcess这个成员变量。

```java
public class MySignal{
 
  protected boolean hasDataToProcess = false;
 
  public synchronized boolean hasDataToProcess(){
    return this.hasDataToProcess;
  }
 
  public synchronized void setHasDataToProcess(boolean hasData){
    this.hasDataToProcess = hasData;
  }
 
}
```

线程A和B必须获得指向一个MySignal共享实例的引用，以便进行通信。如果它们持有的引用指向不同的MySingal实例，那么彼此将不能检测到对方的信号。

#### 忙等待(Busy Wait)

准备处理数据的线程B正在等待数据变为可用。换句话说，它在等待线程A的一个信号，这个信号使hasDataToProcess()返回true。线程B运行在一个循环里，以等待这个信号：

```java
protected MySignal sharedSignal = ...
 
...
 
while(!sharedSignal.hasDataToProcess()){
  //do nothing... busy waiting
}
```

>忙等待没有对运行等待线程的CPU进行有效的利用，除非平均等待时间非常短。否则，让等待线程进入睡眠或者非运行状态更为明智，直到它接收到它等待的信号。

### 线程通信时要注意的问题

未完

## sleep()方法与wait方法的区别

面试：sleep()方法与wait()方法区别。

二者的作用都是`进行等待`。区别在于

1. sleep()方法是Thread对象中定义的方法，而wait()方法定义在Object类中
2. 可以在任意地方调用线程对象的sleep方法,但是wait()方法必须位于同步代码块或者同步方法中
3. 线程在sleep的时候，并不会释放锁，因此其他线程无法获取到锁，因此也无法执行。而wait方法在执行的时候会释放锁，因此其他线程可以获取到锁，可以有机会运行。 


