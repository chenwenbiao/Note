## wait()、notify()、notifyAll()与线程通信方式总结

### 通过wait()、notify()、notifyAll()进行线程通信

线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。例如，线程B可以等待线程A的一个信号，这个信号会通知线程B数据已经准备好了。

Java有一个内建的等待机制来`允许线程在等待信号的时候变为非运行状态`。java.lang.Object 类定义了三个方法，`wait()、notify()和notifyAll()`来实现这个等待机制

一个线程一旦调用了任意对象的wait()方法，就会变为非运行状态，直到另一个线程调用了同一个对象的notify()方法。
`为了调用 wait()或者notify()，线程必须先获得那个对象的锁。也就是说，线程必须在同步块里调用wait()或者notify()。`

```java
public class MonitorObject{
}
 
public class MyWaitNotify{
 
  MonitorObject myMonitorObject = new MonitorObject();
 
  public void doWait(){
    synchronized(myMonitorObject){
      try{
        myMonitorObject.wait();
      } catch(InterruptedException e){...}
    }
  }
 
  public void doNotify(){
    synchronized(myMonitorObject){
      myMonitorObject.notify();
    }
  }
}
```

当一个线程调用一个对象的notify()方法，正在等待该对象的所有线 程中将有一个线程被唤醒并允许执行(校注：这个将被唤醒的线程是随机的，不可以指定唤醒哪个线程),同时也提供了一个notifyAll()方法来唤醒正 在等待一个给定对象的所有线程。

如你所见，不管是等待线程还是唤醒线程都在同步块里调用wait()和notify()。这是强制性的！一个线程如果没有持有对象锁，将不能调用 wait()，notify()或者notifyAll()。否则，会抛出IllegalMonitorStateException异常。

（校注：JVM是这么实现的，当你调用wait时候它首先要检查下当前线程是否是锁的拥有者，不是则抛出IllegalMonitorStateExcept）

但是，这怎么可能？等待线程在同步块里面执行的时候，不是一直持有监视器对象（myMonitorObject）的锁吗？等待线程不能阻塞唤醒线程进入doNotify()的同步块吗？答案是：的确不能。
一旦线程调用了wait()方法，它就释放了所持有的监视器对象上的锁。这将允许其他线程也可以调用 wait()或者notify()。

一旦一个线程被唤醒，不能立刻就退出wait()的方法调用(也就是不能立刻继续接着wait()方法后执行，而是要再次获得锁才可以，因为这个线程还在同步代码块里.)，直到调用notify()的线程退出了它自己的同步块。换句话说：被唤醒的线程必须重新获得 监视器对象的锁，才可以退出wait()的方法调用，因为wait方法调用运行在同步块里面。如果多个线程被notifyAll()唤醒，那么在同一时刻 将只有一个线程可以退出wait()方法，因为每个线程在退出wait()前必须获得监视器对象的锁。

### 其他的线程通信方式

* 通过共享对象通信
* 忙等待

#### 通过共享对象通信

线程间发送信号的一个简单方式是在共享对象的变量里设置信号值。线程A在一个同步块里设置boolean型成员变量 hasDataToProcess为true，线程B也在同步块里读取hasDataToProcess这个成员变量。

```java
public class MySignal{
 
  protected boolean hasDataToProcess = false;
 
  public synchronized boolean hasDataToProcess(){
    return this.hasDataToProcess;
  }
 
  public synchronized void setHasDataToProcess(boolean hasData){
    this.hasDataToProcess = hasData;
  }
 
}
```

线程A和B必须获得指向一个MySignal共享实例的引用，以便进行通信。如果它们持有的引用指向不同的MySingal实例，那么彼此将不能检测到对方的信号。

#### 忙等待(Busy Wait)

准备处理数据的线程B正在等待数据变为可用。换句话说，它在等待线程A的一个信号，这个信号使hasDataToProcess()返回true。线程B运行在一个循环里，以等待这个信号：

```java
protected MySignal sharedSignal = ...
 
...
 
while(!sharedSignal.hasDataToProcess()){
  //do nothing... busy waiting
}
```

>忙等待没有对运行等待线程的CPU进行有效的利用，除非平均等待时间非常短。否则，让等待线程进入睡眠或者非运行状态更为明智，直到它接收到等待的信号。

### 线程通信时要注意的问题

#### 丢失的信号（Missed Signals）

看一段可能丢失信号，可能导致线程永远 不能被唤醒的代码:

```java
public class MonitorObject{
}
 
public class MyWaitNotify{
 
  MonitorObject myMonitorObject = new MonitorObject();
 
  public void doWait(){
    synchronized(myMonitorObject){
      try{
        myMonitorObject.wait();
      } catch(InterruptedException e){...}
    }
  }
 
  public void doNotify(){
    synchronized(myMonitorObject){
      myMonitorObject.notify();
    }
  }
}
```

以上代码，如果通知线程先调用了doNotify()方法，这个时候可能没有线程处于等待状态，通知信号过后便丢 弃了，在通知线程调用doNotify()方法之后，等待线程才被调用，这可能使等待线程永远在等待，不再醒来，因为线程错过了唤醒信号。

为了避免丢失信号，必须把它们保存在信号类里,解决方法如下:
```java
public class MyWaitNotify2{
 
  MonitorObject myMonitorObject = new MonitorObject();
  boolean wasSignalled = false;//表示通知线程是否已经通知过了，
  //如果通知过了，等待线程就不要等待了.
 
  public void doWait(){
    synchronized(myMonitorObject){
      if(!wasSignalled){// 如果通知过了，等待线程就不要等待了.
        try{
          myMonitorObject.wait();
         } catch(InterruptedException e){...}
      }
      //clear signal and continue running.
      wasSignalled = false;
    }
  }
 
  public void doNotify(){
    synchronized(myMonitorObject){
      wasSignalled = true;
      myMonitorObject.notify();
    }
  }
}
```

#### 假唤醒

由于莫名其妙的原因，线程有可能在没有调用过notify()和notifyAll()的情况下醒来。这就是所谓的假唤醒（spurious wakeups）。无端端地醒过来了。

如果发生了假唤醒，等待线程即使没有收到正确的信号，也能够执行后续的操作。这可能导致你的应用程序出现严重问题。

为了防止假唤醒，保存信号的成员变量将在一个while循环里接受检查，而不是在if表达式里。这样的一个while循环叫做自旋锁（校注：这种做法要慎重，目前的JVM实现自旋会消耗CPU，如果长时间不调用doNotify方法，doWait方法会一直自旋，CPU会消耗太大）。被唤醒的线程会自旋直到自旋锁(while循环)里的条件变为false。

```java
public class MyWaitNotify3 {
  MonitoObject myMonitorObject = new MonitorObject();
  boolean wasSignalled = false;

  public void doWait() {
      synchronized(myMonitorObject){
        while(!wasSignalled){
          try{
             myMonitorObject.wait();
           }catch(InterruptedException e){}
        }
        // clear signal and continue running.
        wasSignalled = false;
      }
  }

  public void doNotify(){
    synchronized(myMonitorObject){
      wasSignalled = true;
      myMonitorObject.notify();
    }
  }
}
```

留意wait()方法是在while循环里，而不在if表达式里。如果等待线程没有收到信号就唤醒，wasSignalled变量将变为false,while循环会再执行一次，促使醒来的线程回到等待状态。

#### 多个线程等待相同信号

如果你有多个线程在等待，被notifyAll()唤醒，但只有一个被允许继续执行，使用while循环也是个好方法(上面的MyWaitNotify3)。只有一个线程可以获得监 视器对象锁，意味着只有一个线程可以退出wait()调用，并清除wasSignalled标志（设为false）。一旦这个线程退出doWait()的同 步块，其他等待同样信号的线程就会获得myMonitorObject这个监视器对象锁,这个时候，其他线程退出wait()调用，并在while循环里检查wasSignalled变量值。但是，这个标志已经被第一个唤醒的线程清除了，所以其余 醒来的线程将回到等待状态，直到下次信号到来。

#### 不要在字符串常量或全局对象中调用wait()

```java
public class MyWaitNotify{
 
  String myMonitorObject = "";//使用字符串常量（””）作为管程对象
  boolean wasSignalled = false;
 
  public void doWait(){
    synchronized(myMonitorObject){
      while(!wasSignalled){
        try{
          myMonitorObject.wait();
         } catch(InterruptedException e){...}
      }
      //clear signal and continue running.
      wasSignalled = false;
    }
  }
 
  public void doNotify(){
    synchronized(myMonitorObject){
      wasSignalled = true;
      myMonitorObject.notify();
    }
  }
}
```

使用空字符串(或者其他常量字符串)作为同步块的锁，调用wait()和notify()产生的问题是:

JVM/编译器内部会把常量字符串转换成同一个对象。这意味着，即使你有2个不同的MyWaitNotify实例，它们都引用了相同的空字符串实例(即用了同一把锁)。同时也存在这样的风险：在第一个 MyWaitNotify实例上调用doWait()的线程会被在第二个MyWaitNotify实例上调用doNotify()的线程唤醒。

未完.

## sleep()方法与wait方法的区别

面试：sleep()方法与wait()方法区别。

二者的作用都是`进行等待`。区别在于

1. sleep()方法是Thread对象中定义的方法，而wait()方法定义在Object类中
2. 可以在任意地方调用线程对象的sleep方法,但是wait()方法必须位于同步代码块或者同步方法中
3. 线程在sleep的时候，并不会释放锁，因此其他线程无法获取到锁，因此也无法执行。而wait方法在执行的时候会释放锁，因此其他线程可以获取到锁，可以有机会运行。 


