### 同步原理

>JVM规范规定JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现，而方法同步是使用另外一种方式实现的，但是方法的同步同样可以使用这两个指令来实现。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处， JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor 被某一个线程持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor 的所有权，即尝试获得对象的锁。

同步代码块和锁是Java并发编程中最最核心的概念.Java同步代码块(synchronized block)和锁是用来避免多个线程对共享资源产生竞争，导致运行结果与期望不符合的一种机制.

Java中的同步块用synchronized标记,任何一个对象都可以作为一个锁.Sychronized是可重入的.

>线程竞争案例演示:org.java.core.base.concurrent.chapter3.ThreadCompetitionDemo.java

### 竞态条件与临界区

在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源`做了写操作时才有可能发生`，只要资源没有发生变化,`多个线程读取相同的资源`就是安全的。

当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。例如上面的代码中，我们的count++操作，就是一个临界区,它会产生竞态条件。在临界区中使用适当的同步就可以避免竞态条件。 

实例方法同步:

```java
//注意synchronized关键字告诉Java该方法是同步的。
public synchronized void add(int value){
    this.count += value;
}
```

Java实例方法同步是同步在拥有该方法的对象上,多个线程要运行的是`同一个对象实例`的`同步方法`,如果多线程运行的是`不同的对象实例的同步方法`，是没有同步效果的，因为`每个对象实例是把自身当成锁`，就导致没有公用一个锁。

静态方法同步
```java
public static synchronized void add( int value ){
       count += value ;
     }
```

`静态方法的同步`是指同步在该方法所在的类对象上。因为`在Java虚拟机中一个类只能对应一个类对象`，所以同时只允许`一个线程执行同一个类中的静态同步方法`。

不管类中的哪个静态同步方法被调用，一个类只能由一个线程执行(因为使用的class对象作为锁)。

实例方法中的同步块:
```java
public void add(int value){
    //Java同步块构造器用括号将对象括起来
    //this指调用add方法的实例本身
    //在同步构造器中用括号括起来的对象叫做监视器对象
    synchronized(this){
       this.count += value;
    }
  }
```

静态方法中的同步块：
```java
public static void log2(String msg1, String msg2){
       synchronized(MyClass.class){
          log.writeln(msg1);
          log.writeln(msg2);
       }
    }
```

## 什么样的变量可以成为共享资源？

当多个线程同时访问同一个资源，并且其中的一个或者多个线程对这个资源进行了写操作，才会产生竞态条件

### 局部变量

局部变量存储在线程自己的栈中。也就是说，局部变量永远也不会被多个线程共享。所以，基础类型的局部变量是线程安全的:
```java
public void someMethod(){
  long threadSafeInt = 0;
  threadSafeInt++;
}
```

### 局部对象的引用

对象的局部引用对和基础类型的局部变量不太一样。尽管引用本身没有被共享，但引用所指的对象并没有存储在线程的栈内。所有的对象都存在共享堆中.

如果在某个方法中创建的对象不会逃逸出该方法（译者注：即该对象不会被其它方法获得，也不会被非局部变量引用到），那么它就是线程安全的.

实际上，哪怕将这个对象作为参数传给其它方法，只要别的线程获取不到这个对象，那它仍是线程安全的。下面是一个线程安全的局部引用样例：

```java
public void someMethod(){
  LocalObject localObject = new LocalObject();
  localObject.callMethod();
  method2(localObject);
}
 
public void method2(LocalObject localObject){
  localObject.setValue("value");
}
```

### 对象成员变量

象成员存储在堆上。如果两个线程同时更新`同一个对象的同一个成员`，那这个代码就不是线程安全的.

### 线程控制逃逸规则

如果一个资源的创建，使用，销毁都在同一个线程内完成，
且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。

>Java中你无需主动销毁对象，所以“销毁”指不再有引用指向对象

如果对象本身线程安全，但如果该对象中包含其他共享资源（文件，数据库连接），整个应用也许就不再是线程安全的了。比如2个线程都创建了各自的数据库连接，每个连接自身是线程安全的，但它们所连接到的同一个数据库也许不是线程安全的。

## 同步代码块与隐式锁

java并发编程中，这段代码称之为一个同步代码块：
```java
synchronized(锁对象){
    ...
}
```

### JVM遇到synchronized关键字时如何处理

JVM在遇到synchronized关键字时，会把花括号"{...}"中间的代码当成一个`原子操作`，也就是说，`只有等到同步代码块中的代码在执行完成的时候，CPU才会进行线程的上下文切换`，而不会再同步代码块中的内容只执行了一部分的时候，就切换到其他线程运行。

每个synchronized关键字都必须要配合锁进行使用，在java中，任何对象实例都可以当做一个锁来使用.

每一个java对象都会关联一个`隐式锁`，因此当我们在使用synchronized关键字编写同步代码块时，实际上利用的就是小括号中的java对象的`关联的隐式锁`。

>在使用同步代码块解决多线程竞争共享资源的问题时，我们使用的必须是同一把锁。所谓同一把锁，其实指得就是同一个对象实例

具体实现是在编译之后在同步方法调用前加入一个 `monitor.enter` 指令，在退出方法和异常处插入 `monitor.exit` 的指令.
其本质就是对一个对象监视器( `Monitor` )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的.而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 `monitor.exit` 之后才能尝试继续获取锁.

```java
package com.java.core;

public class HelloWorld {
	public static void main(String[]  args) {
		synchronized(HelloWorld.class) {
			System.out.println("Hello World!!");
		}
	}
}
```

使用`javap -c com.java.core.HelloWorld`可以查看编译之后的具体信息,可以看到在同步块的入口和出口分别有 `monitorenter,monitorexit`指令:

```
public class com.java.core.HelloWorld {
  public com.java.core.HelloWorld();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: ldc           #2                  // class com/java/core/HelloWorld
       2: dup
       3: astore_1
       4: monitorenter
       5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;
       8: ldc           #4                  // String Hello World!!
      10: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V
      13: aload_1
      14: monitorexit
      15: goto          23
      18: astore_2
      19: aload_1
      20: monitorexit
      21: aload_2
      22: athrow
      23: return
    Exception table:
       from    to  target type
           5    15    18   any
          18    21    18   any
}
```

## Java类锁、对象锁、私有锁、隐式锁

1. 类锁：static方法加了synchronized，或者synchronized(xxx.class）的代码段(同步静态方法，锁的是当前 `Class` 对象)
2. 对象锁：方法上加了synchronized，或者synchronized(this）的代码段(同步普通方法，锁的是当前对象)
3. 私有锁：在类内部声明一个私有属性如private Object lock，在需要加锁的代码段synchronized(lock）(同步块)
4. 类锁和对象锁不会产生竞争，二者的加锁方法不会相互影响.
5. 私有锁和对象锁(this)也不会产生竞争，二者的加锁方法不会相互影响。
6. synchronized直接加在方法上和synchronized(this)都是对当前对象加锁，二者的加锁方法够成了竞争关系，同一时刻只能有一个方法能执行。

## 同步方法与同步代码块的区别

另一种提问方式，在实际开发中，是使用同步代码块好，还是使用同步方法好?

这个考验的是实际上是读者对java同步和锁的理解深刻程度。
结论是很明显的，`同步代码块比同步方法好`。原因如下：

1. 我们只需要对临界区的代码进行同步

因为多线程只会对`临界区的代码访问顺序敏感`，因此在执行同步操作的时候，如果使用的是同步方法，那么整个方法中的所有内容都会被当做一个原子操作。而事实上在大多数情况下，我们可能只是方法中某一段内容需要同步，同步代码块可以帮助我们只在必要的地方进行同步。

2. 在同步代码块中，我们可以自由的选择锁

在同步代码块中，我们可以自由的选择任何一个java对象实例作为同步过程中要使用到的锁。但是对于实例同步方法而言，这个锁是不能选择的，就是这个对象实例。对于静态同步方法而言，这个锁就是类的class对象实例。

>不能自由的选择锁，就会产生一个很大的问题。例如我们类中定了两个不同的`实例同步方法`，这两个方法在业务上并没有太多关联。当某个线程在调用其中一个同步实例方法的时候，其他的线程就无法继续调用另外的一个实例同步方法。这是因为，锁只有一个，就是这个类实例对象。必须要等到一个实例同步方法执行完成，把锁释放了之后，其他的线程得到锁，才能执行另外一个同步方法。

因为两个实例同步方法的确没有什么关联，所以我们是希望两个同步方法被同时调用的，只要每个方法中的内容可以原子方式执行即可。但是因为我们使用的是同步方法，而锁只有一个(对象实例)，因此没有关联的两个需要同步执行的方法互相产生了影响。

如果我们使用的是同步代码块，那么我们就可以自由的选择做，我们可以定义两个任意对象的实例作为锁，然后在不同的方法内部使用同步代码块，并且各自使用其中一个锁，这样就可以避免多个同步实例方法彼此之间的项目影响。

### 进程切换导致的系统开销

Java的线程是直接映射到操作系统线程之上的，线程的挂起、阻塞、唤醒等都需要操作系统的参与，
因此线程切换的过程中是有一定的系统开销的。在多线程环境下调用Synchronized方法，有可能需要多次线程状态切换，因此可以说Synchronized是在Java语言中一个`重量级操作`。虽然如此，JDK1.6版本后还是对Synchronized关键字做了相关优化，
加入锁自旋特性减少系统线程切换导致的开销，几乎与ReentrantLock的性能不相上下，因此建议在能满足业务需求的前提下，优先使用Sychronized。

>与其说ReentrantLock性能更好不如说Synchronized优化空间更大,Synchronized在JDK1.6以后性能有所增强，因此在能满足业务复杂度需求的情况下，采用Synchronized也未尝不可。然而互斥同步终究属于悲观的并发策略，在对性能要求极高的业务场景下使用以上互斥同步策略并不合适。接下来进而介绍如何实现乐观的同步策略(也就是CAS)。

### 等待可中断

>等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，这个特性对处理执行时间非常长的同步块很有帮助

### 公平锁

>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。Sychronized的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带boolean值的构造函数要求使用公平锁；

