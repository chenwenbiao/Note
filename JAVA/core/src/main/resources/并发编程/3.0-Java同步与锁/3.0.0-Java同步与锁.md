同步代码块和锁是Java并发编程中最最核心的概念.Java同步代码块(synchronized block)和锁是用来避免多个线程对共享资源产生竞争，导致运行结果与期望不符合的一种机制.

Java中的同步块用synchronized标记,任何一个对象都可以作为一个锁.

>线程竞争案例演示:org.java.core.base.concurrent.chapter3.ThreadCompetitionDemo.java

### 竞态条件与临界区

在同一程序中运行多个线程本身不会导致问题，问题在于多个线程访问了相同的资源。如，同一内存区（变量，数组，或对象）、系统（数据库，web services等）或文件。实际上，这些问题只有在一或多个线程向这些资源`做了写操作时才有可能发生`，只要资源没有发生变化,`多个线程读取相同的资源`就是安全的。

当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。导致竞态条件发生的代码区称作临界区。例如上面的代码中，我们的count++操作，就是一个临界区,它会产生竞态条件。在临界区中使用适当的同步就可以避免竞态条件。 

实例方法同步:

```java
//注意synchronized关键字告诉Java该方法是同步的。
public synchronized void add(int value){
    this.count += value;
}
```

Java实例方法同步是同步在拥有该方法的对象上,多个线程要运行的是`同一个对象实例`的`同步方法`,如果多线程运行的是`不同的对象实例的同步方法`，是没有同步效果的，因为`每个对象实例是把自身当成锁`，就导致没有公用一个锁。

静态方法同步
```java
public static synchronized void add( int value ){
       count += value ;
     }
```

`静态方法的同步`是指同步在该方法所在的类对象上。因为`在Java虚拟机中一个类只能对应一个类对象`，所以同时只允许`一个线程执行同一个类中的静态同步方法`。

不管类中的哪个静态同步方法被调用，一个类只能由一个线程执行(因为使用的class对象作为锁)。

实例方法中的同步块:
```java
public void add(int value){
    //Java同步块构造器用括号将对象括起来
    //this指调用add方法的实例本身
    //在同步构造器中用括号括起来的对象叫做监视器对象
    synchronized(this){
       this.count += value;
    }
  }
```

静态方法中的同步块：
```java
public static void log2(String msg1, String msg2){
       synchronized(MyClass.class){
          log.writeln(msg1);
          log.writeln(msg2);
       }
    }
```

## 什么样的变量可以成为共享资源？

当多个线程同时访问同一个资源，并且其中的一个或者多个线程对这个资源进行了写操作，才会产生竞态条件

### 局部变量

局部变量存储在线程自己的栈中。也就是说，局部变量永远也不会被多个线程共享。所以，基础类型的局部变量是线程安全的:
```java
public void someMethod(){
  long threadSafeInt = 0;
  threadSafeInt++;
}
```

### 局部对象的引用

对象的局部引用对和基础类型的局部变量不太一样。尽管引用本身没有被共享，但引用所指的对象并没有存储在线程的栈内。所有的对象都存在共享堆中.

如果在某个方法中创建的对象不会逃逸出该方法（译者注：即该对象不会被其它方法获得，也不会被非局部变量引用到），那么它就是线程安全的.

实际上，哪怕将这个对象作为参数传给其它方法，只要别的线程获取不到这个对象，那它仍是线程安全的。下面是一个线程安全的局部引用样例：

```java
public void someMethod(){
  LocalObject localObject = new LocalObject();
  localObject.callMethod();
  method2(localObject);
}
 
public void method2(LocalObject localObject){
  localObject.setValue("value");
}
```

### 对象成员变量

象成员存储在堆上。如果两个线程同时更新`同一个对象的同一个成员`，那这个代码就不是线程安全的.

### 线程控制逃逸规则

如果一个资源的创建，使用，销毁都在同一个线程内完成，
且永远不会脱离该线程的控制，则该资源的使用就是线程安全的。

>Java中你无需主动销毁对象，所以“销毁”指不再有引用指向对象

如果对象本身线程安全，但如果该对象中包含其他共享资源（文件，数据库连接），整个应用也许就不再是线程安全的了。比如2个线程都创建了各自的数据库连接，每个连接自身是线程安全的，但它们所连接到的同一个数据库也许不是线程安全的。

## 同步代码块与隐式锁

java并发编程中，这段代码称之为一个同步代码块：
```java
synchronized(锁对象){
    ...
}
```

### JVM遇到synchronized关键字时如何处理

JVM在遇到synchronized关键字时，会把花括号"{...}"中间的代码当成一个`原子操作`，也就是说，`只有等到同步代码块中的代码在执行完成的时候，CPU才会进行线程的上下文切换`，而不会再同步代码块中的内容只执行了一部分的时候，就切换到其他线程运行。

每个synchronized关键字都必须要配合锁进行使用，在java中，任何对象实例都可以当做一个锁来使用.

每一个java对象都会关联一个`隐式锁`，因此当我们在使用synchronized关键字编写同步代码块时，实际上利用的就是小括号中的java对象的`关联的隐式锁`。

>在使用同步代码块解决多线程竞争共享资源的问题时，我们使用的必须是同一把锁。所谓同一把锁，其实指得就是同一个对象实例

## Java类锁、对象锁、私有锁、隐式锁

1. 类锁：在代码中的方法上加了static和synchronized的锁，或者synchronized(xxx.class）的代码段
2. 对象锁：在代码中的方法上加了synchronized的锁，或者synchronized(this）的代码段
3. 私有锁：在类内部声明一个私有属性如private Object lock，在需要加锁的代码段synchronized(lock）
4. 类锁和对象锁不会产生竞争，二者的加锁方法不会相互影响.
5. 私有锁和对象锁(this)也不会产生竞争，二者的加锁方法不会相互影响。
6. synchronized直接加在方法上和synchronized(this)都是对当前对象加锁，二者的加锁方法够成了竞争关系，同一时刻只能有一个方法能执行。

## 同步方法与同步代码块的区别

另一种提问方式，在实际开发中，是使用同步代码块好，还是使用同步方法好?

这个考验的是实际上是读者对java同步和锁的理解深刻程度。
结论是很明显的，`同步代码块比同步方法好`。原因如下：

1. 我们只需要对临界区的代码进行同步

因为多线程只会对`临界区的代码访问顺序敏感`，因此在执行同步操作的时候，如果使用的是同步方法，那么整个方法中的所有内容都会被当做一个原子操作。而事实上在大多数情况下，我们可能只是方法中某一段内容需要同步，同步代码块可以帮助我们只在必要的地方进行同步。

2. 在同步代码块中，我们可以自由的选择锁

在同步代码块中，我们可以自由的选择任何一个java对象实例作为同步过程中要使用到的锁。但是对于实例同步方法而言，这个锁是不能选择的，就是这个对象实例。对于静态同步方法而言，这个锁就是类的class对象实例。

>不能自由的选择锁，就会产生一个很大的问题。例如我们类中定了两个不同的`实例同步方法`，这两个方法在业务上并没有太多关联。当某个线程在调用其中一个同步实例方法的时候，其他的线程就无法继续调用另外的一个实例同步方法。这是因为，锁只有一个，就是这个类实例对象。必须要等到一个实例同步方法执行完成，把锁释放了之后，其他的线程得到锁，才能执行另外一个同步方法。

因为两个实例同步方法的确没有什么关联，所以我们是希望两个同步方法被同时调用的，只要每个方法中的内容可以原子方式执行即可。但是因为我们使用的是同步方法，而锁只有一个(对象实例)，因此没有关联的两个需要同步执行的方法互相产生了影响。

如果我们使用的是同步代码块，那么我们就可以自由的选择做，我们可以定义两个任意对象的实例作为锁，然后在不同的方法内部使用同步代码块，并且各自使用其中一个锁，这样就可以避免多个同步实例方法彼此之间的项目影响。


