## 可重入锁 VS 非可重入锁

可重入锁: 如果一个线程lock了2次,那么释放的时候也要unlock2次.否则锁就不会被完全释放,会被当前线程一直占用着.

>可重入锁指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。

```java
// 类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。
// 因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。

// 如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，
// 实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。
public class Widget {
    public synchronized void doSomething() {
        System.out.println("方法1执行...");
        doOthers();
    }

    public synchronized void doOthers() {
        System.out.println("方法2执行...");
    }
}
```

>通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁,
见org.java.core.base.concurrent.chapter5.MyReentrantLock的nonfairTryAcquire方法.

```java
// 注意jdk是没有这个NonReentrantLock类的，我这里只是说明
public class NonReentrantLock{
    protected boolean tryAcquire(int acquires){
        // 不可以重入锁是直接尝试获取锁，而不判断当前线程是否已经持有锁
        if(this.compareAndSetState(0, 1)){
            this.owner = Thread.currentThread();
            return true;
        }else{
            return false;
        }
    }
    
    protected boolean tryRelease(int releases){
        if(Thread.currentThread() != this.owner){
            throw new IllegalMonitorStateException();
        }else{
            this.owner = null;
            this.setState(0);// 直接将state置位0
            return true;
        }
    }
}
```