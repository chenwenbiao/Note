# 4类引用的特点

<table>
    <thead>
        <tr>
            <th>引用类型</th>
            <th>被垃圾回收时间</th>
            <th>用途</th>
            <th>生存时间</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>强引用</td>
            <td>从来不会，jvm宁可抛出oom</td>
            <td>对象的一般状态</td>
            <td>JVM停止运行是终止</td>
        </tr>
        <tr>
            <td>软引用</td>
            <td>内存不足时</td>
            <td>对象缓存</td>
            <td>内存不足时终止</td>
        </tr>
        <tr>
            <td>弱引用</td>
            <td>垃圾回收时</td>
            <td>对象缓存</td>
            <td>GC运行后停止</td>
        </tr>
        <tr>
            <td>虚引用</td>
            <td>none</td>
            <td>none</td>
            <td>none</td>
        </tr>
    </tbody>
</table>

Java这四种引用的级别由高到低依次为：`强引用 > 软引用 > 弱引用 > 虚引用`

## 强引用

>强引用是使用最普遍的引用：`Object o=new Object();` 特点：如果一个对象具有强引用，那么垃圾回收器绝不会回收它.
当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题,将对象的引用显示地置为null：`o=null; `(帮助垃圾收集器回收此对象),则GC认为该对象不存在引用，这时就可以回收这个对象，具体什么时候回收主要取决于GC的算法实现机制。

```java
// 该方法内部拥有一个强引用book，这个引用将会保存在栈中，
// 而真正的引用对象（new Book()）则保存在堆中。当这个方法运行完之后，就会退出方法栈，
// 则引用对象的引用不再存在，这个对象就会被回收。
// 但如果这个book是全局变量时，就需要在不用这个对象时赋值为null，因为强引用不会被垃圾回收。
public void printBookInfo(){
		Book book = new Book();
		Book.getBookInfo();
}
```

```java
// 举例ArrayList的实现源代码
transient Object[] elementData; // non-private to simplify nested class access

public void clear() {
    modCount++;
    // clear to let GC do its work
    // 在调用clear方法清空数组时可以看到为每个数组内容赋值为null。不同于elementData=null
    // 不同于elementData=null，强引用仍然存在，避免在后续调用add()等方法添加元素时进行重新的内存分配。
    // 使用如clear()方法中释放内存的方法对数组中存放的引用类型特别适用，这样就可以及时释放内存。
    for (int i = 0; i < size; i++)
        elementData[i] = null;
    size = 0;
}
```

## 软引用

>用来描述一些还有用但是并非必须的对象，在Java中用java.lang.ref.SoftReference类来表示。对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。

```java
// 浏览器网页缓存实例：
Browser browser = new Browser();//获取页面进行浏览
SoftReference softBrowser = new SoftReference<Browser>(browser);//浏览完毕之后设置为软引用
if(softBrowser != null){
  browser = (Browser) softBrowser.get();//如果没有被GC回收，直接获取
}else{
  browser = new Browser();//由于内存不足，导致软引用被GC回收，若是现在再使用的话，则直接创建
  softBrowser = new SoftReference<Browser>(browser);//重新设置为软引用
}
```

```java
// 当内存不足时等价于
if(jvm.内存不足()){
    browser = null;//转换为弱引用
    System.gc();// 进行垃圾回收
}
```

## 弱引用

>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 Weak Reference 来记住此对象。(不介入这个对象的生命周期)

```java
//强引用
Book book = new Book();
//弱引用
WeakReference<Book> weakReference = new WeakReference<Book>(book);

//当垃圾回收器进行扫描回收时等价于：
book = null;
System.gc();

// 下面的代码会让Book变为一个强引用：
Book book = weakReference.get();
```

## 虚引用

>虚引用也称为幻影引用：一个对象有虚引用的存在不会对对象的生存时间都构成影响，
也无法通过虚引用来获取对一个对象的真实引用。唯一的用处：能在对象被GC时收到系统通知，
JAVA中用PhantomReference来实现虚引用。

