1. 什么是 Fork/Join 框架

Fork/Join框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，
最终汇总每个小任务结果后得到大任务结果的框架。

我们再通过Fork和Join这两个单词来理解下Fork/Join框架，
Fork(叉子)就是把一个大任务切分为若干子任务并行的执行，
Join 就是合并这些子任务的执行结果，最后得到这个大任务的结果。

2. 工作窃取(work-stealing)算法

工作窃取算法是指某个线程从其他队列里窃取任务来执行。

那么为什么需要使用工作窃取算法呢？假如我们需要做一个比较大的任务，
我们可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，
于是把这些子任务分别放到不同的队列里，我们得到了多个任务队列，并为每个队列创建一个单独
的线程来执行队列里的任务，线程和队列一一对应，比如 A 线程负责处理 A 队列里的任务。
但是有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。
干完活的线程与其等着，不如去帮其他线程干活，于是它就去其他线程的队列里窃取一个任务
来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，
通常会使用“双端队列”，被窃取任务线程永远从双端队列的头部拿任务执行，
而窃取任务的线程永远从双端队列的尾部拿任务执行。

工作窃取算法的优点是充分利用线程进行并行计算，并减少了线程间的竞争，
其缺点是在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且消耗了更多的系统资源，
比如创建多个线程和多个双端队列。

3. Fork/Join 框架的介绍

我们已经很清楚 Fork/Join 框架的需求了，那么我们可以思考一下，
如果让我们来设计一个Fork/Join框架，该如何设计？
这个思考有助于你理解 Fork/Join 框架的设计。

第一步分割任务：首先我们需要有一个fork类来把大任务分割成子任务，有可能子任务还是很大，
所以还需要不停的分割，直到分割出的子任务足够小。

第二步执行任务并合并结果：分割的子任务分别放在双端队列里，
然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都统一放在一个队列里，
启动一个线程从队列里拿数据，然后合并这些数据。

Fork/Join使用两个类来完成以上两件事情：

a. ForkJoinTask：我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。
它提供在任务中执行 fork() 和 join() 操作的机制，
通常情况下我们不需要直接继承 ForkJoinTask 类，而只需要继承它的子类，
Fork/Join 框架提供了以下两个子类：
    RecursiveAction：用于没有返回结果的任务。
    RecursiveTask ：用于有返回结果的任务。

b. ForkJoinPool ：ForkJoinTask 需要通过 ForkJoinPool 来执行，
任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。
当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。

4. 使用 Fork/Join 框架

让我们通过一个简单的需求来使用下Fork／Join框架，需求是：计算 1+2+3+4 的结果。

使用 Fork／Join 框架首先要考虑到的是如何分割任务，
如果我们希望每个子任务最多执行两个数的相加，那么我们设置分割的阈值是2，
由于是 4 个数字相加，所以 Fork／Join 框架会把这个任务 fork 成两个子任务，
子任务一负责计算 1+2，子任务二负责计算 3+4，然后再 join 两个子任务的结果。

因为是有结果的任务，所以必须继承 RecursiveTask，实现代码见CountTask.

通过这个例子让我们再来进一步了解ForkJoinTask，ForkJoinTask与一般的任务的主要区别在于它需要实现compute 方法，
在这个方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。
如果不足够小，就必须分割成两个子任务，每个子任务在调用 fork 方法时，又
会进入 compute 方法，看看当前子任务是否需要继续分割成孙任务，
如果不需要继续分割，则执行当前子任务并返回结果。
使用 join 方法会等待子任务执行完并得到其结果。