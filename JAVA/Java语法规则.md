this：
    概念：  当前对象的引用
        this定义在方法中，当哪个对象调用这个方法，则this代表哪个对象。
    用法：
        使用this区分成员变量与局部变量
        在方法内，使用this访问的为成员变量，不用this访问的默认为局部变量。
        如果方法中访问了一个变量，而该方法中没有定义一个该名称的局部变量，则会继续从成员位置找该变量。
成员变量与局部变量区别     
    1. 定义位置上的区别
    成员变量,定义在类中,方法外
    局部变量,方法内,语句内

    2. 作用域不同
        成员变量,作用范围是整个类
        局部变量,方法内,语句内

    3. 默认值不同
        成员变量,有自己的默认值
        局部变量,没有默认值,不赋值不能使用

    4. 内存位置不同
        成员变量,跟随对象进入堆内存存储
        局部变量,跟随自己的方法,进入栈内存

    5. 生命周期不同
        成员变量,跟随对象,在堆中存储,内存等待JVM清理  生命相对较长
        局部变量,跟随方法,方法出栈,就消失                生命相对较短


继承：
    类与类之间的关系

    如果多个类具有相同的属性和行为，我们可以抽取出共性的内容定义父类，这时再创建相似的类时只要继承父类即可
    
    当一个类的属性与行为均与现有类相似，属于现有类的一种时，这一个类可以定义为现有类的子类
    
    子类会自动拥有父类所有可继承的属性和方法，无需重新定义。并且可以直接使用非私有的父类成员。
    从类与类之间的设计关系来看,子类必须属于父类的一种时，才会继承。
    
    继承的关键字 extends   
        子类   extends  父类{}
    继承的好处：
        提高了代表的可维护性
        提高了代码的复用性
        让类与类之间产生了继承关系
    继承的弊端：
        类与类之间的耦合度过高
    继承特点：
        java中类只能够单继承，不能多继承，可以多层继承
        class Ye extends Object {}
        class Fu extends Ye{}
        class Zi extends Fu {}
        所有的类都直接或者间接的继承了 Object类，Object类称为祖宗类
    继承的注意事项：
        1，使用关键字 extends 让类与类之间 产生继承关系
        2, 父类私有的成员，子类不能继承，因为根本看不到
        3，不能为了继承某个功能而随意进行继承操作， 必须要符合 is a 的关系
            苹果 is a 水果
            男人 is a 人
            狗   is a 人 ， 这种情况就不能继承了
    变量的就近访问原则
        局部变量>子类成员变量>父类成员变量
        this.变量名     访问本类变量
        super.变量名    访问父类变量

        this.方法名()     访问本来方法
        super.方法名()    访问父类方法


    
方法重写：
    在继承关系中，子类可以重新定义父类继承过来的方法，可以将没有方法体的方法加上方法体，完成具体事项，也可以将有方法体的方法重写，
    让该功能更为强大。
    
    当创建对象时，调用的为子类重写后的方法。
    
    注意事项：
        权限修饰符，子父类相同或者子类大
        方法名、参数，返回值类型子父类必须相同
    
抽象类/抽象方法：

    抽象类概述：当使用面向对象的方式描述现实生活中的事物时，有些概念比较泛泛抽象的，不需要创建实例对象。
    而又需要定义这样一个类，规定其子类所应该具备的成员变量和成员方法时，可以将一个事物定义为
    抽象类，该类的方法一般为抽象方法，没有实现体。具体的实现由子类自己完成。

    抽象方法：只有方法声明，没有方法体的方法，叫做抽象方法
    抽象类：包含抽象方法的类，就是抽象类
    
    抽象类/抽象方法 注意事项：
        抽象类不能创建对象，只能被子类继承，出现的意义就是为了让子类继承，重写方法，规定了其子类的通用功能和属性
        如果一个类继承了抽象类，则需要重写其所有抽象方法，才能创建对象，否则仍为抽象类
        
        抽象类不一定包含抽象方法。
        抽象类可以有非抽象方法。
        
        


        接口
    (1)当抽象类中的方法都是抽象的时候，java就提供了一种新的表现形式：接口。接口是功能的集合 接口不能创建对象
    (2)格式：
        接口：
            public interface Inter
            {
            
            }

        实现类：
            public class InterImpl implements Inter
            {
            
            }
    (3)接口的特点：
        A:不需要被abstract修饰。
        B:类实现接口,可以单实现,还可以多实现。
        C:接口可以继承接口,可以单继承，也可以多继承。
        D:接口与父类的功能可以重复，均代表要具备某种功能。
    (4)抽象类和接口的区别:
        A:成员的区别
            抽象类：
                成员变量：可以是变量，也可以是常量。
                //构造方法：有构造方法，用于子类实例化使用。
                成员方法：可以是抽象的，也可以是非抽象的。

            接口：
                成员变量：只能是常量。
                      默认修饰符：public static final
                成员方法：只能是抽象的。
                      默认修饰符：public abstract

                推荐：默认修饰符请自己永远手动给出。

        B:类和接口的关系区别
            类与类：
                继承关系,只能单继承。可以多层继承。

            类与接口：
                实现关系,可以单实现,也可以多实现。
                类还可以在继承一个类的同时实现多个接口。

            接口与接口：
                继承关系,可以单继承,也可以多继承。

        C:体现的理念不同
            抽象类里面定义的都是一个继承体系中的共性内容。
                
            接口是功能的集合,是一个体系额外的功能，是暴露出来的规则。
                

多态
    (1)同一个对象，在不同时刻表现出来的不同状态。
        举例：水(水,冰,水蒸气)
              猫(猫,动物)
              
    (2)前提：
        A:有继承或者实现关系。
        B:有方法的重写。
        C:有父类(接口)的引用指向子类对象。
    (3)多态中的成员使用特点：
        Fu fz = new Zi();
        多态时，所有表现形式都是父类的表现形式，
        只有调用方法时，运行的是子类重写的方法
        A:成员变量
            编译看左边，运行看左边。
        B:成员方法
            编译看左边，运行看右边。

         class Fu {
            int num=1;
            void show() {
                System.out.println("showFu");
            }
        }
        class Zi extends Fu {
            int num=2;
            void show() {
                System.out.println("showZi");
            }
        }
        class T {
            public static void main(String[] args) {
                Fu f=new Zi();
                System.out.println(f.num);  
                f.show();   
                
            }

    (4)多态中的转型：
        A:向上转型
            把子类对象赋值给父类(接口)的引用  自动类型提升  int a = 0;  double b =a;
        B:向下转型
            把父类(接口)的引用强制转换成子类对象
            double b = 10.0;
            int a = (int)b;

            Fu  fz = new Zi();(前提)
            Zi  zf = (Zi)fz;


    (5)多态的好处及弊端：
        A:好处
            提高了程序可维护性和可扩展性。
            
        B:弊端
            不能使用子类特有内容。
            要想使用，要么向下转型，要么重新创建子类对象。
    (6)多态的三种形式：
        A:具体的类多态   父类  变量名 = new  子类();
            public class Fu {
                public void show(){
                    System.out.println("父类的show方法");
                }
            }
            public class Zi extends Fu{
                @Override
                public void show(){
                    System.out.println("子类重写父类的show方法");
                }
            }
            Fu fu= new Zi();
        B:抽象类多态     父抽象类  变量名 = new 子类();
            public abstract class Fu {
                public abstract void method();
            }
            public class Zi extends Fu {
                public void method(){
                    System.out.println(“重写父类抽象方法”);
                }
            }
            //类的多态使用
            Fu fu= new Zi();
        C:接口多态       接口  变量名  =  new 实现类();
        public interface Fu {
            public abstract void method();
        }
        public class Zi implements Fu {
            public void method(){
                System.out.println(“重写接口抽象方法”);
            }
        }
    instanceof 关键字:用于引用数据类型判断
        格式： 对象名 instanceof 类名
        返回值： true, false
        作用： 判断某个对象是否属于某种数据类型

        构造方法：
    
    用来创建对象的，同时还可以为成员变量赋值  
    
    
    奇怪的定义格式： 没有返回值类型     方法名称与类名相同    参数根据需求而定
    学习阶段，一般定义两个构造方法
    一般定义空参构造与满参构造
    class Person {
        private String name;
        //空参构造
        public Person() {}
        //满参构造，为了方便我们创建对象时，为成员变量赋值
        public Person(String name) {
            this.name = name;
        }
    }
    
    调用构造方法格式：
        创建对象
            new Person();
            new Person("路人甲");

        在构造方法中，使用this/super调用构造方法

    构造方法注意事项
        如果没有手动给出任意构造方法，系统会默认给出一个空参构造方法，
        如果手动给出了任意一个构造方法，系统都不会空参构造方法了
        子类的任意构造方法的第一行都默认调用了父类的空参构造方法super()
        可以使用super(参数)的方式来调用父类的带参构造来为成员变量赋值

        
this：本类对象的空间
super：本类对象中的父类对象空间

this：
    访问本类对象成员变量              this.变量名
    调用本类普通方法                this.方法名(参数)
    本类构造方法调用本类其他构造          本类构造方法第一行this(参数)
    
super：
    访问本类对象当中的父类对象成员变量       super.变量名
    调用本类对象当中的父类普通方法         super.方法名()
    本类构造方法调用父类构造            本类构造方法第一行super(参数)

    this与super在调用构造方法时，均必须在第一行，只能调用其中的一个。
    父类多个构造，子类调用父类某个参数的构造时，必须保证父类有这个构造，否则报错

    

final：
    final是最终修饰符，可以修饰类、成员方法、变量。
    final修饰的类：最终的类，不能被继承
    final修饰的变量： 相当于是一个常量,  一次赋值,终身不变
    final修饰的方法： 最终的方法，子类不能重写，可以继承过来使用

    final修饰的引用数据类型变量，可以修改对象里面的属性内容，不可改变地址值
    final修饰的成员变量，不能使用默认值，必须在创建对象之前完成赋值。

static:
    静态修饰符，被static修饰的内容属于类不专属于某个对象，多个对象共享使用这一个成员
    使用static修饰的成员可以用类名直接访问，建议这样使用：
        类名.静态方法名(参数);
        类名.静态常量名;
    静态修饰的成员只能直接访问静态修饰的成员，不能出现this、super,因为类是优于对象产生
    
匿名对象：没有名字的对象，没有赋值给某个变量的对象
        匿名对象如果始终没有给某个变量赋值，则只能使用一次
        匿名对象可以作为方法接收的参数、方法返回值使用
        
内部类的概念：定义在一个类的内部的一个类叫内部类   分为：成员内部类与局部内部类
匿名内部类：
    是局部内部类的一种
    匿名内部类完成两件事：
        1：定义了一个类型的匿名子类
        2：定义类后，即刻创建了该类对象
    
    目的：为了创建某个类的子类对象
    格式：new 父类/接口() {
            重写方法
        };
    
包：软件组织文件的基本方式,用于将相同功能的类放到同一个包下，方便管理
  在类的最前边使用package定义类所在包，注意：声明的package包必须与这个文件所在的文件夹一致
包的访问：(前提 类用public修饰)
    同一个包下，随意访问
    不同包下：
        可以直接使用全名使用
            创建对象格式：包名.类名 变量名 = new包名.类名();
        为了方便，可以选择导包后，再直接使用类名本身，不加包名  在package后，class前使用import导入类
        如果是lang包下的类，可以不导包，直接使用
访问权限：
    权限修饰符
        public : 公共的
        protected: 受保护的
        默认的：不写就是默认的default
        private : 私有的
                    public  protected   默认的 private
        在当前类中       Y       Y           Y       Y
        同一包中的其他类Y       Y           Y
        不同包中的子类 Y       Y
        不同包中的其他类Y
代码块：一块执行代码的区域用{}包裹
        局部代码块：定义在方法中的，用来限制变量的作用范围
        构造代码块：定义在类中方法外，用来给对象中的成员初始化赋值
        静态代码块：定义在类中方法外，用来给类的静态成员初始化赋值
        静态代码块:不管创建几次对象,只执行一次
        构造代码块:new一次,就执行一次,优先于构造方法
        构造方法:new一次,就执行一次

        一个类默认是有一个无参的构造器，以防止程序猿不定义构造器，
但是如果人为的定义了一个构造器，系统默认的无参数的构造器就不起作用了，因为假设此类必须要通过构造器传入一些
必须的参数才可以使用其功能，要不然就不能使用此类，所以如果无参数的
构造器还起作用，那么使用其功能方法的时候就有问题.

类的成员变量，如果没有初始化，会有默认值:
boolean falg; //flag 默认false
String str; //str 默认为null

abstract class可以有非abstract 方法

接口interface也是可以继承接口interface的

switch语句可以使用的类型: int, enum

null instanceof String;//false

自己定义的那个AIDL接口所在的包的包名必须保持客户端和服务器端一致，

java转义字符：

 \0：空字符 

一个方法被定义为final，说明这个方法不可以被覆盖.

wireshark过滤http方法: http.request.method == "POST"

Java函数内部的变量必须要初始化才能使用，函数内部的局部变量是没有默认值的，
如果不初始化，编译就编译不过去，会提示错误.

Timer对调度的支持是基于绝对时间的，而不是相对时间，所以它对系统时间的改变非常敏感。
其次 Timer 线程是不会捕获异常的，如果 TimerTask 抛出的了未检查异常则会导致 Timer 线程终止，同时 Timer 也不会重新恢复线程的执行，他会错误的认为整个 Timer 线程都会取消。同时，已经被安排单尚未执行的 TimerTask 也不会再执行了，新的任务也不能被调度。故如果 TimerTask 抛出未检查的异常，Timer 将会产生无法预料的行为。

对于 Timer 的缺陷，我们可以考虑 ScheduledThreadPoolExecutor 来替代。
Timer 是基于绝对时间的，对系统时间比较敏感，而 ScheduledThreadPoolExecutor 则是基于相对时间；
Timer 是内部是单一线程，而 ScheduledThreadPoolExecutor 内部是个线程池，所以可以支持多个任务并发执行。

实现接口不允许使用@Override,

素数/质数

斐波那契数列