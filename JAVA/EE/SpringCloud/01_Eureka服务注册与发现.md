# Eureka的自我保护机制

## 导致的原因

默认情况下，如果EurekaServer在一定的时间内没有接收到某一个微服务实例的心跳，EurekaServer将会注销该实例，页面就会看见一串红色提示，但是当网络分区发生故障时，微服务与EurekaServer无法进行正常的通信，此时本不应该注销这个微服务实例，这个时候，Eureka的自我保护机制就可以解决这个问题，当EurekaServer节点在短时间内丢失过多的客户端时（可能发生了网络故障），那么这个节点就会进入自我保护模式，一旦进入该模式，EurekaServer就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务），当网络故障恢复后，该EurekaServer节点就会自动退出自我保护模式。

## 总结

在自我保护模式下，EurekaServer会保护服务注册表中的信息，不再注销任何服务实例，当它收到的心跳数重新到阈值以上，该EurekaServer就会自动退出自我保护模式，也就是宁可保留错误的服务注册信息，也不盲目的删除任何可能健康的服务实例。

# Eureka集群配置

microservicecloud-eureka-7001是EurekaServer服务注册中心，一旦这个出现问题，那么微服务就不能正常的工作，为防止这种情况，所以出现了集群，就是建立多个服务注册中心:microservicecloud-eureka-7002，microservicecloud-eureka-7003等

# Eureka和Zookeeper区别

## 遵循原则不同

**Eureka遵循AP原则，Zookeeper遵循CP原则**，C：强一致性，A：可用性，P：分区容错性

著名的CAP理论中提出，一个分布式系统不可能同时满足C(一致性)A(可用性)P(分区容错性)，由于分区容错性p是分布式系统中必须保证，因此只能在A和C之间权衡

## Zookeeper保证CP

在Zookeeper中存在一种情况下，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举，但是，选举leader的时间太长，且选举过程中这个Zookeeper集群是不可用的，这就导致在选举期间注册服务瘫痪，在云部署的环境中，因为网络问题使得Zookeeper集群失去master节点的可能性较大，虽然服务最终能够恢复，但是在漫长的选举时间导致的注册时间不可用是不能容忍的，当我们向注册中心查询注册列表时，可以忍受注册中心返回的是几分钟以前的注册信息，但是不能接收服务直接down不可用，也就是说，服务注册对可用性的要求高于一致性。

## Eureka保证AP

Eureka知道Zookeeper的不足，所以设计最初就保证可用性，Eureka各个节点都是平等的，几个节点的挂点不会影响其他正常节点的工作，剩余的节点仍然可以提供注册和查询服务，只不过不能保证查询的信息是最新的，除此之外，Eureka还有一种自我保护机制，当过多的节点没有正常的心跳时，那么Eureka就会认为客户端出现了网络故障，此时Eureka会

- Eureka不会从注册表中移除因为长时间没有收到心跳而应该过期的服务
- Eureka仍然能够接受新服务的注册和查询请求，但是不会同步到其他节点上（保证当前节点可用）
- 当网络稳定时，当前实例新的注册信息会被同步到其他节点上