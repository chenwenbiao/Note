# Selector

选择器Selector提供了选择执行已经就绪的任务的能力就绪选择和多元执行使得单线程能够有效率地同时管理多个I/O通道(channels)。 C/C++代码的工具箱中，许多年前就已经有 select()和 poll()这两个POSIX（可移植性操作系统接口）系统调用可供使用了。许多操作系统也提供相似的功能，但对Java 程序员来说，就绪选择功能直到 JDK 1.4 才成为可行的方案。

## 选择器基础

引入了Selector的概念之后，我们需要将之前创建的一个或多个Channel注册到Selector对象中，
然后一个键(SelectionKey)将会被返回。
SelectionKey会记住您关心的通道。它们也会追踪对应的通道是否已经就绪,
如图:Selector01.png

>每个Channel在注册到Selector上的时候，都有一个感兴趣的操作:

1. 对于ServerSocketChannel，只会在Selector上注册一个，它感兴趣的操作是ACCEPT，`表示其只关心客户端的连接请求`
2. 对于SocketChannel，会在Selector上注册多个，因为一个server通常会接受到多个client的请求，就有对应数量的SocketChannel。
`SocketChannel感兴趣的操作是CONNECT、READ、WRITE，因为其要于server建立连接，也需要进行读、写数据`.

Selector提供了询问通道(Channel)是否已经准备好执行每个I/0操作的能力。例如，
我们需要了解一个 SocketChannel 对象是否还有更多的字节需要读取，
或者我们需要知道ServerSocketChannel是否有需要准备接受的连接。

当调用一个Selector对象的select()方法时，相关的SelectionKey 会被更新，
用来检查所有被注册到该Selector的Channel是否已经准备就绪。也就是说，程序需要主动的去调用Selector.select()方法。select() 方法会返回一个准备就绪的SelectionKey的集合。通过遍历这些键，您可以选择出每个从上次您调用 select()开始直到现在，已经就绪的通道。

在与SelectableChannel联合使用时，就绪选择的真正价值在于潜在的大量的通道可以同时进行就绪状态的检查。调用者可以轻松地决定多个通道中的哪一个准备好要运行。有两种方式可以选择：被激发的线程可以处于休眠状态，直到一个或者多个注册到选择器的通道就绪，或者它也可以周期性地轮询选择器，看看从上次检查之后，是否有通道处于就绪状态。如果您考虑一下需要管理大量并发的连接的网络服务器(web server)的实现，就可以很容易地想到如何善加利用这些能力。

>这就是为什么传统的监控多个 socket 的 Java 解决方案是为每个socket创建一个线程并使得线程可以在 read( )调用中阻塞，直到数据可用。这事实上将每个被阻塞的线程当作了 socket 监控器，并将 Java虚拟机的线程调度当作了通知机制。这两者本来都不是为了这种目的而设计的。程序员和Java 虚拟机都为管理所有这些线程的复杂性和性能损耗付出了代价，这在线程数量的增长失控时表现得更为突出。

>真正的就绪选择必须由操作系统来做。操作系统的一项最重要的功能就是处理I/O 请求并通知各个线程它们的数据已经准备好了。选择器类提供了这种抽象，使得 Java 代码能够以可移植的方式，请求底层的操作系统提供就绪选择服务。

## 选择器Selector常用方法

1.   Set<SelectionKey>	keys() 返回SelectionKey集合，代表注册在该Selector上的channel
2.   Set<SelectionKey>	selectedKeys()被选择的SelectionKey集合，返回此Selector的已选择键集。
3.   int  select() 监控所有注册的Channel，当他们中间有需要处理的IO操作时，该方法返回，并将对应得SelectionKey加入被选择的SelectionKey集合中，该方法返回这些Channel的数量。
4.   int select(long timeout) 选择一组键，其相应的通道已为 I/O 操作准备就绪。
5.  Set<SelectionKey>	selectedKeys() 返回此选择器的已选择键集。
6.  int	selectNow()  选择一组键，其相应的通道已为 I/O 操作准备就绪。
7.  Selector wakeup() 使尚未返回的第一个选择操作立即返回。

### 选择键(SelectionKey)

> SelectionKey：表示的是SelectableChannel和Selector之间的注册关系，每次向选择器注册通道时就会选择一个事件，
选择键包含两个表示为整数的操作集，操作集的每一位都表示该键的通道所支持的一类可选择操作。其中SelectionKey的实例方法如下;

1. int	interestOps() 获取此键的 interest 集合。
2. SelectionKey	interestOps(int ops) 将此键的 interest 集合设置为给定值。
3. boolean	isAcceptable()  测试此键的通道是否已准备好接受新的套接字连接。
4. boolean	isConnectable() 测试此键的通道是否已完成其套接字连接操作。
5. boolean	isReadable() 测试此键的通道是否已准备好进行读取。
6. boolean	isValid() 告知此键是否有效。
7. isWritable() 测试此键的通道是否已准备好进行写入。
8. int	readyOps()获取此键的 ready 操作集合。


## 使用Selection



### 并发性

选择器对象是线程安全的，但它们包含的键集合不是。

protected Set<SelectionKey> selectedKeys = new HashSet();
protected HashSet<SelectionKey> keys = new HashSet();
private final Set<SelectionKey> cancelledKeys = new HashSet<SelectionKey>();
可以看到选择键的集合是HashSet类型，HashSet是线程不安全。

  通过 keys( )和 selectKeys( )返回的键的集合是 Selector 对象内部的私有的 Set 对象集合的直接引用。这些集合可能在任意时间被改变。已注册的键的集合是只读的。如果您试图修它 ， 那么您得到的奖品将是一个java.lang.UnsupportedOperationException。

但是当您在观察它们的时候，它们可能发生了改变的话，您仍然会遇到麻烦。 Iterator 对象是快速失败的(fail-fast)：如果底层的 Set 被改变了，它们将会抛出 java.util.ConcurrentModificationException，因此如果您期望在多个线程间共享选择器和/或键，请对此做好准备。您可以直接修改选择键，但请注意您这么做时可能会彻底破坏另一个线程的 Iterator。

如果在多个线程并发地访问一个选择器的键的集合的时候存在任何问题，您可以采取一些步骤来合理地同步访问。在执行选择操作时，选择器在 Selector 对象上进行同步，然后是已注册的键的集合，最后是已选择的键的集合，按照这样的顺序。已取消的键的集合也在选择过程的的第 1步和第 3 步之间保持同步（当与已取消的键的集合相关的通道被注销时）。

在多线程的场景中，如果您需要对任何一个键的集合进行更改，不管是直接更改还是其他操作带来的副作用，您都需要首先以相同的顺序，在同一对象上进行同步。锁的过程是非常重要的。如果竞争的线程没有以相同的顺序请求锁，就将会有死锁的潜在隐患。如果您可以确保否其他线程不会同时访问选择器，那么就不必要进行同步了。

  Selector 类的 close( )方法与 select( )方法的同步方式是一样的，因此也有一直阻塞的可能性。在选择过程还在进行的过程中，所有对 close( )的调用都会被阻塞，直到选择过程结束，或者执行选择的线程进入睡眠。在后面的情况下，执行选择的线程将会在执行关闭的线程获得锁是立即被唤醒，并关闭选择器 。

### 异步关闭能力

任何时候都有可能关闭一个通道或者取消一个选择键。除非您采取步骤进行同步，否则键的状态及相关的通道将发生意料之外的改变。一个特定的键的集合中的一个键的存在并不保证键仍然是有效的，或者它相关的通道仍然是打开的。

关闭通道的过程不应该是一个耗时的操作。 NIO 的设计者们特别想要阻止这样的可能性：一个线程在关闭一个处于选择操作中的通道时，被阻塞于无限期的等待。当一个通道关闭时，它相关的键也就都被取消了。这并不会影响正在进行的 select( )，但这意味着在您调用 select( )之前仍然是有效的键，在返回时可能会变为无效。您总是可以使用由选择器的 selectKeys( )方法返回的已选择的键的集合：请不要自己维护键的集合。理解 之前描述的选择过程，对于避免遇到问题而言是非常重要的。

如果您试图使用一个已经失效的键，大多数方法将抛出 CancelledKeyException。但是，您可以安全地从从已取消的键中获取通道的句柄。如果通道已经关闭时，仍然试图使用它的话，在大多数情况下将引发 ClosedChannelException。

### 选择过程的可扩展性

我多次提到选择器可以简化用单线程同时管理多个可选择通道的实现。使用一个线程来为多个通道提供服务，通过消除管理各个线程的额外开销，可能会降低复杂性并可能大幅提升性能。但只使用一个线程来服务所有可选择的通道是否是一个好主意呢？这要看情况。

对单 CPU 的系统而言这可能是一个好主意，因为在任何情况下都只有一个线程能够运行。通过消除在线程之间进行上下文切换带来的额外开销，总吞吐量可以得到提高。但对于一个多 CPU的系统呢？在一个有 n 个 CPU 的系统上，当一个单一的线程线性地轮流处理每一个线程时，可能有 n-1 个 cpu 处于空闲状态。

那么让不同道请求不同的服务类的办法如何？想象一下，如果一个应用程序为大量的分布式的传感器记录信息。每个传感器在服务线程遍历每个就绪的通道时需要等待数秒钟。这在响应时间不重要时是可以的。但对于高优先级的连接（如操作命令），如果只用一个线程为所有通道提供服务，将不得不在队列中等待。不同的应用程序的要求也是不同的。您采用的策略会受到您尝试解决的问题的影响。

在第一个场景中，如果您想要将更多的线程来为通道提供服务，请抵抗住使用多个选择器的欲望。在大量通道上执行就绪选择并不会有很大的开销，大多数工作是由底层操作系统完成的。管理多个选择器并随机地将通道分派给它们当中的一个并不是这个问题的合理的解决方案。这只会形成这个场景的一个更小的版本。

一个更好的策略是对所有的可选择通道使用一个选择器，并将对就绪通道的服务委托给其他线程。您只用一个线程监控通道的就绪状态并使用一个协调好的工作线程池来处理共接收到的数据。根据部署的条件，线程池的大小是可以调整的（或者它自己进行动态的调整）。对可选择通道的管理仍然是简单的，而简单的就是好的。

第二个场景中，某些通道要求比其他通道更高的响应速度，可以通过使用两个选择器来解决：一个为命令连接服务，另一个为普通连接服务。但这种场景也可以使用与第一个场景十分相似的办法来解决。与将所有准备好的通道放到同一个线程池的做法不同，通道可以根据功能由不同的工作线程来处理。它们可能可以是日志线程池，命令/控制线程池，状态请求线程池，等等。

由于执行选择过程的线程将重新循环并几乎立即再次调用 select( )，键的 interest 集合将被修改，并将 interest（感兴趣的操作）从读取就绪(read-rreadiness)状态中移除。这将防止选择器重复地调用 readDataFromSocket( )（因为通道仍然会准备好读取数据，直到工作线程从它那里读取数据）。当工作线程结束为通道提供的服务时，它将再次更新键的 ready 集合，来将 interest 重新放到读取就绪集合中。它也会在选择器上显式地嗲用 wakeup( )。如果主线程在 select( )中被阻塞，这将使它继续执行。这个选择循环会再次执行一个轮回（可能什么也没做）并带着被更新的键重新进入select( )。

