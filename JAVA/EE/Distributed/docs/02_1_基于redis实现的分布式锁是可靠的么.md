# 基于redis设计的分布式锁是真正可靠的么?(可靠性论证)

Martin认为现在 Redis 逐渐被使用到数据管理领域，这个领域需要更强的数据一致性和耐久性(持久性)，这使得他感到担心，因为这不是 Redis 最初设计的初衷,(redis一开始是为缓存而设计的)（事实上这也是很多业界程序员的误区，越来越把 Redis 当成数据库在使用），其中基于 Redis 的分布式锁就是令人担心的其一。

# 结论

Martin指出首先要明确你为什么使用redis/redisson分布式锁，为了提高性能还是正确性？为了帮你区分这二者，在这把锁出现问题的时候你可以询问自己以下问题： 

## 对于要提升性能的场景

- **要性能的：** 拥有这把锁使得你不会重复劳动（例如一个操作做了两次），如果这把锁出现问题了，两个节点同时做了这个 操作，那么这个 操作 增加了你的成本

如果你的应用只需要高性能的分布式锁不要求多高的正确性，那没必要用 Redlock，对于需求`性能`(注意区别数据一致性)的分布式锁应用它太重了且成本高,太复杂，直接使用Redis操作来提升性能就够了，最多加个slave防止master宕机,没必要使用redlock提升性能.

使用Redis,那么断电或者一些其他情况下，你会丢失锁(主从复制是异步的,锁还没有来及复制到slave)，但是你的目的只是加速性能且断电这种事情不会经常发生，这并不是什么大问题,因为你只是为了提升性能,可以损失一些正确性,那么很显然你这个应用需要的`锁粒度是很模糊粗糙的，也不会是什么重要的服务。`

## 对于需求正确,数据一致性的场景(秒杀,生成全局递增id)

- **要正确性的：** 拥有锁可以防止并发操作导致数据不一致，如果这把锁出现问题,两个节点同时操作了一份数据，结果可能是数据不一致、数据丢失、操作冲突等问题，会导致严重的后果。(这是我们讨论redis分布式锁的主要场景)

那么是否 Redlock 对于要求正确性的场景就合适呢？Martin 列举了若干场景证明 Redlock 这种算法是不可靠的(也就是可能会生成重复id)。对于需求正确性的应用来说它不够安全。；

如果你的应用想要保住正确性，那么不建议 Redlock，建议使用一个合适的一致性协调系统，例如 Zookeeper，且保证存在 fencing token。

> redisson虽然不是绝对完美,但是已经相对完美了.

# redis/redisson为什么不能保证正确性/数据一致性?

在分布式环境下，因为涉及到不同node、网络通信并且他们随时可能无征兆的宕机等问题。

Martin 假设了一个场景，一个 client 要修改一个文件，它先申请得到锁，然后修改文件写回，放锁。另一个 client 再申请锁.

可惜即使你的锁服务非常完美，上述代码还是可能出现问题

![](https://martin.kleppmann.com/2016/02/unsafe-lock.png)

上图中，得到锁的 client1 在持有锁的期间 pause 了一段时间，例如 GC 停顿。锁有过期时间（一般叫租约，为了防止某个 client 崩溃之后一直占有锁），但是如果 GC 停顿太长超过了锁租约时间，此时锁已经被另一个 client2 所得到，原先的 client1 还没有感知到锁过期，那么奇怪的结果就会发生，曾经 HBase 就发生过这种 Bug。

即使你在 client1 写回之前检查一下锁是否过期能改善这个问题，但也不是完美的.

## 使用token使得锁变安全

你需要在每次写操作时加入一个 token。这个场景下，token 可以是一个递增的数字，每次有 client 申请锁就递增一次：

![](https://martin.kleppmann.com/2016/02/fencing-tokens.png)

client1 申请锁同时拿到 token33，然后它进入长时间的停顿锁也过期了。client2 得到锁和 token34 写入数据，紧接着 client1 活过来之后尝试写入数据，自身 token33 比 34 小因此写入操作被拒绝。注意这需要存储层来检查 token，但这并不难实现。

>如果你使用 Zookeeper 作为锁的话那么你可以使用 zxid 作为递增数字。

但是对于 Redlock 你要知道，没什么生成 token 的方式，并且没办法修改 Redlock 算法使其能产生 token,redisson官方没有提供,因为产生 token 需要单调递增，除非在单节点 Redis 上完成但是单节点这又没有高可靠性.

Redlock 无法产生 token 早该成为在需求正确性的场景下弃用它的理由.
