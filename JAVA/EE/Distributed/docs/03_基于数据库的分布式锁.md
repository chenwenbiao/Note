# 数据库的唯一索引

>注意:这种方法了解即可,不用细纠,主要是太复杂了.会有各种各样的问题，方案复杂

![](基于数据库表01.png)

![](https://pic2.zhimg.com/80/v2-f6c9c90bc4d2be833703d449ebad0b25_hd.jpg)

当我们想要锁住某个方法时，执行以下SQL：

![](https://pic4.zhimg.com/80/v2-545076f21fa335f7d6acd4a1966c3af7_hd.jpg)

![](基于数据库表02.png)

![](https://pic2.zhimg.com/80/v2-903452fb1f2ccbc214c7e4b280a08619_hd.jpg)

存在以下几个问题：

- 锁没有失效时间，解锁失败的话其它进程无法再获得该锁。
- 锁只能是非阻塞锁，插入失败直接就报错了，没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作.
- 不可重入，已经获得锁的进程也必须重新获取锁。

![](解决上面的问题.png)

# 结论

基于数据库的分布式锁太复杂了.