# 分布式锁(分布式互斥锁)

在单jvm实例的时候,可以基于cpu的cas（compare And Swap）控制，以及java语法自带的锁,可以很好的解决多线程高并发下的资源抢占问题。那么，跨jvm进程的多实例呢？

在分布式场景下，对不同机器上的不同进程进行加锁，就需要使用分布式锁。

很多大型网站都是分布式部署，分布式场景中的数据一致性问题一直是一个比较重要的话题。在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。

在很多互联网产品应用中，有些场景需要加锁处理，比如：秒杀(总数是有限的)，全局递增ID等。

![](线程锁和分布式锁(进程锁).png)

# 分布式锁应该有的功能

1. 安全:互斥,任何时候,只有一个客户端能持有同一个锁.
2. 不会死锁:最终client一定会得到锁,就算一个持有锁的客户端宕掉或者发生网络分区异常.
3. 分区容错性:当部分节点宕机时,客户端仍然能够获取锁和释放锁

# 分布式锁一般有三种实现方式：

业界常用的解决方案通常是借助于一个第三方组件自身的排他性来达到多进程的互斥。如：

1. 基于数据库.
2. 基于ZooKeeper的分布式锁;(个人感觉此方法比较好)
3. 基于Redis的分布式锁；(`NX EX`,redis原子操作实现分布式锁)

>哪种方式都无法做到完美。需要根据不同的应用场景选择最适合自己的才是王道。

# 实现的复杂性角度（从低到高）

>Zookeeper >= 缓存 > 数据库

# 性能角度（从高到低）

> 缓存 > Zookeeper >= 数据库

# 可靠性角度（从高到低）

>Zookeeper > 缓存 > 数据库