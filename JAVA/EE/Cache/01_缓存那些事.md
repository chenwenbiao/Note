# 缓存

## 为什么需要缓存

现在互联网应用（网站或App）的整体流程，可以概括如下图所示，用户请求从界面（浏览器或App界面）到网络转发、再到应用服务再到存储（数据库或文件系统），然后返回到界面呈现内容。

往往我们的应用服务器资源是有限的，数据库每秒能接受的请求次数也是有限的（或者文件的读写也是有限的），如何能够有效利用有限的资源来提供尽可能大的吞吐量？一个有效的办法就是引入缓存，打破标准流程，每个环节中请求可以从缓存中直接获取目标数据并返回，从而减少计算量，有效提升响应速度，让有限的资源服务更多的用户。

缓存在日常开发中举足轻重，如果你的应用对某类数据有着较高的读取频次，并且改动较小时那就非常适合利用缓存来提高性能。

![](互联网应用一般流程.png)

# 缓存特点 

## 命中率:

当某个请求能够通过访问缓存而得到响应时，称为缓存命中。缓存命中率越高，缓存的利用率也就越高。

## 最大空间

* 缓存通常位于内存中，内存的空间通常比磁盘空间小的多，因此缓存的最大空间不可能非常大。
* 当缓存存放的数据量超过最大空间时，那么将会触发缓存启动清空策略,就需要淘汰部分数据来存放新到达的数据。
* 根据不同的场景合理的设置最大元素值往往可以一定程度上提高缓存的命中率，从而更有效的时候缓存。

## 清空策略/淘汰策略

设计适合自身数据特征的清空策略能有效提升命中率。常见的一般策略有：

- FIFO(first in first out):先进先出策略，最先进入缓存的数据在缓存空间不够的情况下（超出最大元素限制）会被优先被清除掉，以腾出新的空间接受新的数据。`策略算法主要比较缓存元素的创建时间。在数据实效性要求场景下,需要经常访问最新的数据，那么就可以使用 FIFO，使得最先进入的数据（最旧的数据）被淘汰。`

- LFU(less(较少，更少) frequently used):最少使用策略(最不频繁使用策略)，指的是在一段时间内，数据被使用次数最少的，优先被淘汰。无论是否过期，根据元素的被使用次数判断，清除使用次数较少的元素释放空间。该策略和LRU的区别是，在一段时间内，LRU优先淘汰最后一次使用时间距离当前时间最久的，而LFU优先淘汰最近一段时间内使用次数最少的。`策略算法主要比较元素的hitCount（命中次数）`。在保证高频数据有效性场景下，可选择这类策略。

- LRU(least recently used)
最近最少使用策略(最近最久未使用策略)，优先淘汰上次被访问时间距离现在最久的数据。该策略可以保证内存中的数据都是热点数据，也就是经常被访问的数据，从而保证缓存命中率。无论是否过期，根据元素最后一次被使用的时间戳，清除距离现在最远使用时间戳的元素释放空间。`策略算法主要比较元素最近一次被get使用时间。在热点数据场景下较适用，优先保证热点数据的有效性。`

除此之外，还有一些简单策略比如：

- 根据过期时间判断，清理过期时间最长的元素；
- 根据过期时间判断，清理最近要过期的元素；
- 随机清理；
- 根据关键字（或元素内容）长短清理等。

## 虽然从硬件介质上来看，无非就是内存和硬盘两种，但从技术上，可以分成内存、硬盘文件、数据库(非关系数据库)。

* 内存：将缓存存储于内存中是最快的选择，`无需额外的I/O开销`，但是内存的缺点是没有持久化落地物理磁盘，一旦应用异常break down而重新启动，数据很难或者无法复原。
* 硬盘：一般来说，很多缓存框架会结合使用内存和硬盘，在内存分配空间满了或是在异常的情况下，可以被动或主动的将内存空间数据持久化到硬盘中，达到释放空间或备份数据的目的。
* 数据库：前面有提到，增加缓存的策略的目的之一就是`为了减少数据库的I/O压力`。现在使用数据库做缓存介质是不是又回到了老问题上了？其实，数据库也有很多种类型，像那些不支持SQL，只是简单的key-value存储结构的特殊数据库（如BerkeleyDB和Redis），响应速度和吞吐量都远远高于我们常用的关系型数据库等。

## 那么实际工程中我们怎么去对缓存分类呢？

在目前的应用服务框架中，比较常见的，是根据缓存与应用的藕合度，分为`local cache（本地缓存）和remote cache（分布式缓存）`：

### 本地缓存

本地缓存(local cache)：指的是在应用中的缓存组件，其最大的优点是应用和cache是在同一个进程内部，请求缓存非常快速，没有过多的网络开销等，它的缺点也是因为缓存跟应用程序耦合，多个应用程序无法直接的共享缓存，各个应用或集群的各节点都需要维护自己的单独缓存，对内存是一种浪费。

>在单应用不需要集群支持或者集群情况下各节点无需互相通知的场景下使用本地缓存较合适；

### 分布式缓存

分布式缓存(remote cache)：指的是`与应用分离`的缓存组件或服务，其最大的优点是`自身就是一个独立的应用，与本地应用隔离，多个应用可直接的共享缓存。`

目前各种类型的缓存都活跃在成千上万的应用服务中，`还没有一种缓存方案可以解决一切的业务场景或数据类型`，我们需要根据自身的特殊场景和背景，选择最适合的缓存方案。缓存的使用是程序员、架构师的必备技能，好的程序员能根据数据类型、业务场景来准确判断使用何种类型的缓存，如何使用这种缓存，以最小的成本最快的效率达到最优的目的。
